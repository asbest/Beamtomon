<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beamtomon: Office Editions</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 720px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            width: 100%;
            height: 100%;
            background-color: #000;
            display: block;
            image-rendering: pixelated; 
        }

        /* Virtual Controls */
        .controls-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .joystick-area {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
            transition: opacity 0.3s;
        }
        
        .joystick-area:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .actions {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 180px;
            height: 150px;
            pointer-events: auto;
        }

        .action-btn {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.25);
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 24px;
            touch-action: manipulation;
            transition: transform 0.1s;
            text-shadow: 0 2px 2px rgba(0,0,0,0.25);
        }

        .action-btn:active, .action-btn.active {
             background: rgba(255, 255, 255, 0.25);
             transform: scale(0.95);
        }

        .btn-a { bottom: 20px; right: 0px; background-color: rgba(0, 255, 0, 0.15); }
        .btn-b { bottom: 0px; right: 90px; background-color: rgba(255, 0, 0, 0.15); }

        /* Game Over Modal */
        #game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        .modal-content {
            background: #2c3e50;
            padding: 40px;
            border: 4px solid #fff;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
        }

        .modal-title {
            font-size: 48px;
            color: #e74c3c;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 2px 2px 0px #000;
        }

        .modal-score {
            font-size: 24px;
            margin-bottom: 30px;
            color: #f1c40f;
        }

        .restart-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border-radius: 5px;
            border-bottom: 4px solid #1e8449;
            transition: transform 0.1s;
        }

        .restart-btn:active {
            transform: translateY(2px);
            border-bottom: 2px solid #1e8449;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="game-over-modal" class="hidden">
            <div class="modal-content">
                <div class="modal-title">Burnout!</div>
                <div class="modal-score" id="final-score">Score: 0</div>
                <button class="restart-btn" onclick="restartGame()">Back to Work</button>
            </div>
        </div>

        <div class="controls-container">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>
            <div class="actions">
                <div class="action-btn btn-a" data-key="Enter">A</div>
                <div class="action-btn btn-b" data-key="Escape">B</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const TILE_SIZE = 40;
        const SCREEN_WIDTH = 800;
        const SCREEN_HEIGHT = 600;
        const MAP_COLS = SCREEN_WIDTH / TILE_SIZE;
        const MAP_ROWS = SCREEN_HEIGHT / TILE_SIZE;

        // Tile Types
        const TILE_FLOOR = 0;
        const TILE_WALL = 1;

        // Object Types
        const OBJ_NONE = 0;
        const OBJ_DESK = 1;
        const OBJ_CHAIR = 2;
        const OBJ_PLANT = 3;
        const OBJ_PRINTER = 4;
        const OBJ_COFFEE_MACHINE = 5;
        const OBJ_EXIT_DOOR = 6; // NEW: The Exit

        // Colors
        const COLOR_FLOOR = '#e0e0e0';
        const COLOR_WALL = '#555555';
        const COLOR_MENU_BG = '#303030';
        const COLOR_MENU_BORDER = '#ffffff';

        // Game State
        const STATE_WORLD = 'WORLD';
        const STATE_BATTLE = 'BATTLE';
        const STATE_GAME_OVER = 'GAME_OVER';
        let currentState = STATE_WORLD;
        let shakeAmount = 0;
        let battleCooldown = 0; 
        
        // Progression
        let currentStage = 1;
        let mapSeedVal = 100; // Base seed

        // Pseudo Random Number Generator for Deterministic Maps
        function prng() {
            var x = Math.sin(mapSeedVal++) * 10000;
            return x - Math.floor(x);
        }

        // Input
        const keys = {};
        let joystickVector = { x: 0, y: 0 };
        let joystickTimer = 0;

        // Visual Effects
        const floatingTexts = [];

        // Player Object
        const player = {
            x: 100,
            y: 100,
            width: 30,
            height: 30,
            speed: 200,
            color: '#3498db',
            type: "Beamter",
            level: 1,
            hp: 20,
            maxHp: 20,
            xp: 0,
            nextLevelXp: 50,
            score: 0,
            consultants: 0,
            animFrame: 0
        };

        // Trackers
        let coffeeMachineLoc = { x: 0, y: 0 };
        let exitDoorLoc = { x: 0, y: 0 };

        // Data
        const TITLES = ["Anwärter", "Inspektor", "Oberinspektor", "Amtmann", "Amtsrat"];
        const PLAYER_ATTACKS = [
            { name: "Permission Denied", damage: 4 },
            { name: "Pass the Buck", damage: 6 },
            { name: "Coffee Break", damage: 2, heal: true },
            { name: "Form A38", damage: 8 }
        ];

        const ENEMY_MOVES = {
            "Consultant": [
                { name: "Synergy Strike", damage: 5 },
                { name: "Mass Layoff", damage: 9 },
                { name: "Buzzword Blast", damage: 3 },
                { name: "Circle Back", damage: 4 }
            ],
            "Politician": [
                { name: "Empty Promise", damage: 2 },
                { name: "Tax Hike", damage: 7 },
                { name: "Filibuster", damage: 4 },
                { name: "Scandal", damage: 8 }
            ],
            "Citizen": [
                { name: "Complaint", damage: 3 },
                { name: "Angry Email", damage: 4 },
                { name: "Phone Call", damage: 2 },
                { name: "Form Request", damage: 1 }
            ],
            "Colleague": [
                { name: "Reply All", damage: 5 },
                { name: "Gossip", damage: 3 },
                { name: "Microwave Fish", damage: 6 },
                { name: "Meeting Invite", damage: 4 }
            ]
        };
        
        const ENEMY_TYPES = [
            { name: "Consultant", color: "#f1c40f", shirt: "#f1c40f", pants: "#2c3e50", hp: 15, xp: 20 },
            { name: "Politician", color: "#9b59b6", shirt: "#8e44ad", pants: "#2c3e50", hp: 25, xp: 30 },
            { name: "Citizen", color: "#2ecc71", shirt: "#27ae60", pants: "#ecf0f1", hp: 10, xp: 10 },
            { name: "Colleague", color: "#95a5a6", shirt: "#7f8c8d", pants: "#34495e", hp: 20, xp: 25 }
        ];

        // Map Data
        const worldMap = [];
        const objectMap = [];
        const enemies = [];

        // --- Drawing Helpers ---

        function circle(ctx, x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function roundRect(ctx, x, y, w, h, r, color, stroke) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();
            if (stroke) {
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawCharacter(ctx, x, y, type, scale = 1, isBack = false, animOffset = 0) {
            const w = 30 * scale;
            const h = 30 * scale;
            const cx = x + w / 2;
            const cy = y + h / 2;

            let skinColor = '#ffdbac';
            let shirtColor = '#3498db';
            let pantsColor = '#2c3e50';
            let hairColor = '#5d4037';
            let hasTie = true;
            let hasGlasses = true;

            if (type === "Consultant") {
                shirtColor = '#f1c40f'; pantsColor = '#34495e'; hairColor = '#f39c12'; hasGlasses = false;
            } else if (type === "Politician") {
                shirtColor = '#8e44ad'; pantsColor = '#2c3e50'; hairColor = '#bdc3c7'; hasTie = true;
            } else if (type === "Citizen") {
                shirtColor = '#2ecc71'; pantsColor = '#95a5a6'; hasTie = false; hasGlasses = false;
            } else if (type === "Colleague") {
                shirtColor = '#95a5a6'; pantsColor = '#34495e';
            }

            const bob = Math.sin(Date.now() / 200) * (2 * scale);
            const drawY = y + bob;

            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, y + h - 2*scale, w/2, h/6, 0, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + w*0.2, drawY + h*0.4, w*0.6, h*0.4);

            ctx.fillStyle = pantsColor;
            ctx.fillRect(x + w*0.25, drawY + h*0.75, w*0.2, h*0.25);
            ctx.fillRect(x + w*0.55, drawY + h*0.75, w*0.2, h*0.25);

            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.arc(cx, drawY + h*0.25, w*0.3, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = hairColor;
            ctx.beginPath();
            if (isBack) {
                ctx.arc(cx, drawY + h*0.25, w*0.32, Math.PI, Math.PI*2); 
                ctx.fillRect(x + w*0.2, drawY + h*0.25, w*0.6, h*0.2); 
            } else {
                ctx.arc(cx, drawY + h*0.22, w*0.32, Math.PI*1.1, Math.PI*1.9);
            }
            ctx.fill();

            if (!isBack) {
                ctx.fillStyle = 'black';
                if (hasGlasses) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1 * scale;
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(cx - w*0.15, drawY + h*0.2, w*0.12, h*0.1);
                    ctx.strokeRect(cx - w*0.15, drawY + h*0.2, w*0.12, h*0.1);
                    ctx.fillRect(cx + w*0.03, drawY + h*0.2, w*0.12, h*0.1);
                    ctx.strokeRect(cx + w*0.03, drawY + h*0.2, w*0.12, h*0.1);
                } else {
                    ctx.fillRect(cx - w*0.12, drawY + h*0.22, 2*scale, 2*scale);
                    ctx.fillRect(cx + w*0.08, drawY + h*0.22, 2*scale, 2*scale);
                }

                if (hasTie) {
                    ctx.fillStyle = '#c0392b';
                    ctx.beginPath();
                    ctx.moveTo(cx, drawY + h*0.4);
                    ctx.lineTo(cx + w*0.05, drawY + h*0.6);
                    ctx.lineTo(cx, drawY + h*0.65);
                    ctx.lineTo(cx - w*0.05, drawY + h*0.6);
                    ctx.fill();
                }
                
                if (type === "Beamter" || type === "Consultant") {
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 1 * scale;
                    ctx.beginPath();
                    ctx.moveTo(cx, drawY + h*0.4);
                    ctx.lineTo(cx, drawY + h*0.8);
                    ctx.stroke();
                }
            }
            
            ctx.fillStyle = shirtColor;
            ctx.beginPath();
            ctx.ellipse(x + w*0.1, drawY + h*0.5, w*0.1, h*0.2, 0, 0, Math.PI*2);
            ctx.ellipse(x + w*0.9, drawY + h*0.5, w*0.1, h*0.2, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        function drawObject(ctx, x, y, type) {
            // Shadow common to all
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(x + 2, y + TILE_SIZE - 5, TILE_SIZE - 4, 4);

            if (type === OBJ_DESK) {
                ctx.fillStyle = '#5d4037'; ctx.fillRect(x + 5, y + 15, 5, 20); ctx.fillRect(x + 30, y + 15, 5, 20);
                ctx.fillStyle = '#8d6e63'; ctx.fillRect(x + 2, y + 10, 36, 12);
                ctx.fillStyle = '#795548'; ctx.fillRect(x + 2, y + 22, 36, 3);
                ctx.fillStyle = 'white'; ctx.fillRect(x + 8, y + 12, 8, 6);
                ctx.fillStyle = '#ddd'; ctx.fillRect(x + 10, y + 11, 8, 6);
            } else if (type === OBJ_CHAIR) {
                ctx.fillStyle = '#333'; ctx.fillRect(x + 12, y + 25, 3, 10); ctx.fillRect(x + 25, y + 25, 3, 10);
                ctx.fillStyle = '#222'; ctx.fillRect(x + 10, y + 20, 20, 5);
                ctx.fillStyle = '#111'; ctx.fillRect(x + 10, y + 5, 20, 15);
            } else if (type === OBJ_PLANT) {
                ctx.fillStyle = '#d35400';
                ctx.beginPath(); ctx.moveTo(x + 10, y + 35); ctx.lineTo(x + 30, y + 35); ctx.lineTo(x + 32, y + 20); ctx.lineTo(x + 8, y + 20); ctx.fill();
                circle(ctx, x + 20, y + 15, 8, '#27ae60'); circle(ctx, x + 12, y + 18, 6, '#2ecc71'); circle(ctx, x + 28, y + 18, 6, '#2ecc71'); circle(ctx, x + 20, y + 8, 7, '#2ecc71');
            } else if (type === OBJ_PRINTER) {
                ctx.fillStyle = '#bdc3c7'; ctx.fillRect(x + 5, y + 10, 30, 20);
                ctx.fillStyle = '#7f8c8d'; ctx.fillRect(x + 5, y + 10, 30, 5);
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(x + 10, y + 10); ctx.lineTo(x + 15, y + 5); ctx.lineTo(x + 25, y + 5); ctx.lineTo(x + 30, y + 10); ctx.fill();
                ctx.fillStyle = '#2ecc71'; ctx.fillRect(x + 28, y + 12, 3, 3);
            } else if (type === OBJ_COFFEE_MACHINE) {
                ctx.fillStyle = '#555'; ctx.fillRect(x+5, y+20, 30, 15);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(x+10, y+5, 20, 25);
                ctx.fillStyle = '#000'; ctx.fillRect(x+9, y+5, 22, 5);
                ctx.fillStyle = '#444'; ctx.fillRect(x+12, y+15, 16, 12);
                ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(x+14, y+17, 12, 10);
                ctx.fillStyle = '#3e2723'; ctx.fillRect(x+15, y+20, 10, 7);
                ctx.fillStyle = 'red'; ctx.fillRect(x+25, y+8, 2, 2);
            } else if (type === OBJ_EXIT_DOOR) {
                // Determine if locked or unlocked
                const locked = enemies.length > 0;
                ctx.fillStyle = locked ? '#c0392b' : '#2ecc71'; // Red if locked, Green if open
                ctx.fillRect(x + 5, y + 5, 30, 35);
                
                // Door Frame
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(x + 5, y + 5, 30, 35);
                
                // Knob
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(x + 28, y + 25, 3, 0, Math.PI*2);
                ctx.fill();
                
                // Lock Icon or Arrow
                ctx.fillStyle = '#fff';
                if (locked) {
                    // X
                    ctx.font = "bold 14px Arial";
                    ctx.fillText("X", x+15, y+20);
                } else {
                    // Arrow Up
                    ctx.font = "bold 14px Arial";
                    ctx.fillText("↑", x+15, y+20);
                }
            }
        }

        // --- Maze & Map Generation ---
        
        function initMap() {
            // Reset seed for this stage
            mapSeedVal = 100 + currentStage * 997; // Deterministic seed based on stage

            worldMap.length = 0;
            objectMap.length = 0;
            enemies.length = 0;

            for (let r = 0; r < MAP_ROWS; r++) {
                const row = new Array(MAP_COLS).fill(TILE_WALL);
                const objRow = new Array(MAP_COLS).fill(OBJ_NONE);
                worldMap.push(row);
                objectMap.push(objRow);
            }

            const stack = [];
            const startR = 1;
            const startC = 1;
            
            worldMap[startR][startC] = TILE_FLOOR;
            stack.push({r: startR, c: startC});

            // For tracking distance to exit
            let floorTiles = [];

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                const directions = [
                    {dr: -2, dc: 0}, // Up
                    {dr: 2, dc: 0},  // Down
                    {dr: 0, dc: -2}, // Left
                    {dr: 0, dc: 2}   // Right
                ];

                for (let d of directions) {
                    const nr = current.r + d.dr;
                    const nc = current.c + d.dc;

                    if (nr > 0 && nr < MAP_ROWS - 1 && nc > 0 && nc < MAP_COLS - 1) {
                        if (worldMap[nr][nc] === TILE_WALL) {
                            neighbors.push({r: nr, c: nc, linkR: current.r + d.dr/2, linkC: current.c + d.dc/2});
                        }
                    }
                }

                if (neighbors.length > 0) {
                    // Use PRNG for maze layout
                    const next = neighbors[Math.floor(prng() * neighbors.length)];
                    worldMap[next.linkR][next.linkC] = TILE_FLOOR;
                    worldMap[next.r][next.c] = TILE_FLOOR;
                    floorTiles.push({r: next.r, c: next.c}); // Track floor
                    stack.push({r: next.r, c: next.c});
                } else {
                    stack.pop();
                }
            }

            // Mark Original Paths
            const isPath = worldMap.map(row => [...row]);

            const numRooms = 5;
            for (let i = 0; i < numRooms; i++) {
                // Use PRNG for rooms
                const w = Math.floor(prng() * 3) + 3;
                const h = Math.floor(prng() * 3) + 3;
                const r = Math.floor(prng() * (MAP_ROWS - h - 2)) + 1;
                const c = Math.floor(prng() * (MAP_COLS - w - 2)) + 1;

                for (let rr = r; rr < r + h; rr++) {
                    for (let cc = c; cc < c + w; cc++) {
                        const wasWall = worldMap[rr][cc] === TILE_WALL;
                        worldMap[rr][cc] = TILE_FLOOR;
                        
                        if (wasWall) {
                             if (prng() < 0.4) {
                                const roll = prng();
                                if (roll < 0.4) objectMap[rr][cc] = OBJ_DESK;
                                else if (roll < 0.6) objectMap[rr][cc] = OBJ_CHAIR;
                                else if (roll < 0.8) objectMap[rr][cc] = OBJ_PLANT;
                                else objectMap[rr][cc] = OBJ_PRINTER;
                            } else {
                                objectMap[rr][cc] = OBJ_NONE;
                            }
                        } else {
                            objectMap[rr][cc] = OBJ_NONE;
                        }
                    }
                }
            }

            // Place Exit Door (Furthest point roughly)
            if (floorTiles.length > 0) {
                // Pick a tile far from start (simple approx using end of array or random from end)
                // Since it's DFS, end of array is usually deep in maze
                let exitNode = floorTiles[floorTiles.length - 1]; 
                // Ensure it is empty
                objectMap[exitNode.r][exitNode.c] = OBJ_EXIT_DOOR;
                exitDoorLoc = { r: exitNode.r, c: exitNode.c };
            }

            // Place Coffee Machine
            let coffeePlaced = false;
            let coffeeAttempts = 0;
            while (!coffeePlaced && coffeeAttempts < 500) {
                const r = Math.floor(prng() * (MAP_ROWS - 2)) + 1;
                const c = Math.floor(prng() * (MAP_COLS - 2)) + 1;
                if (worldMap[r][c] === TILE_FLOOR && objectMap[r][c] === OBJ_NONE) {
                    objectMap[r][c] = OBJ_COFFEE_MACHINE;
                    coffeeMachineLoc = { x: c * TILE_SIZE + TILE_SIZE/2, y: r * TILE_SIZE + TILE_SIZE/2 };
                    coffeePlaced = true;
                }
                coffeeAttempts++;
            }

            let spawnFound = false;
            for(let r=1; r<MAP_ROWS; r++) {
                for(let c=1; c<MAP_COLS; c++) {
                    if(worldMap[r][c] === TILE_FLOOR && objectMap[r][c] === OBJ_NONE) {
                        player.x = c * TILE_SIZE + 5;
                        player.y = r * TILE_SIZE + 5;
                        objectMap[r][c] = OBJ_NONE;
                        if (c+1 < MAP_COLS) objectMap[r][c+1] = OBJ_NONE;
                        spawnFound = true;
                        break;
                    }
                }
                if(spawnFound) break;
            }

            // Spawn Enemies (Scale count with stage)
            const enemyCount = 8 + currentStage * 2;
            for (let i = 0; i < enemyCount; i++) {
                spawnEnemy();
            }
        }

        function spawnEnemy() {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 100) {
                const r = Math.floor(prng() * (MAP_ROWS - 2)) + 1;
                const c = Math.floor(prng() * (MAP_COLS - 2)) + 1;
                const x = c * TILE_SIZE + 5;
                const y = r * TILE_SIZE + 5;
                attempts++;

                if (worldMap[r][c] !== TILE_WALL && objectMap[r][c] === OBJ_NONE) {
                    const dx = x - player.x;
                    const dy = y - player.y;
                    if (dx*dx + dy*dy > 10000) {
                        const type = ENEMY_TYPES[Math.floor(prng() * ENEMY_TYPES.length)];
                        enemies.push({
                            ...type,
                            type: type.name === "Consultant" ? "Consultant" : 
                                  type.name === "Politician" ? "Politician" :
                                  type.name === "Citizen" ? "Citizen" : "Colleague",
                            x: x,
                            y: y,
                            maxHp: type.hp + currentStage * 2, // Harder enemies
                            hp: type.hp + currentStage * 2,
                            xp: type.xp + currentStage * 5,
                            id: Math.random() // Unique ID
                        });
                        placed = true;
                    }
                }
            }
        }

        initMap();

        // --- Input Handling ---

        window.addEventListener('keydown', (e) => {
            if (currentState === STATE_GAME_OVER) return;
            if (keys[e.key]) return;
            keys[e.key] = true;
            if (currentState === STATE_BATTLE) handleBattleInput(e.key);
            else if (currentState === STATE_WORLD) handleWorldInput(e.key);
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joystick-knob');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        const maxRadius = 50;

        function handleStart(e) {
            if (currentState === STATE_GAME_OVER) return;
            e.preventDefault();
            joystickActive = true;
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            handleMove(e);
        }

        function handleMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const dx = clientX - joystickCenter.x;
            const dy = clientY - joystickCenter.y;
            const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
            const angle = Math.atan2(dy, dx);

            const knobX = Math.cos(angle) * distance;
            const knobY = Math.sin(angle) * distance;

            knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            joystickVector.x = knobX / maxRadius;
            joystickVector.y = knobY / maxRadius;
        }

        function handleEnd(e) {
            e.preventDefault();
            joystickActive = false;
            joystickVector = { x: 0, y: 0 };
            knob.style.transform = `translate(-50%, -50%)`;
        }

        joystick.addEventListener('mousedown', handleStart);
        joystick.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        document.querySelectorAll('.action-btn').forEach(btn => {
             const key = btn.getAttribute('data-key');
             const trigger = () => {
                 if (currentState === STATE_GAME_OVER) return;
                 if (currentState === STATE_BATTLE) handleBattleInput(key);
                 else if (currentState === STATE_WORLD) handleWorldInput(key);
                 keys[key] = true;
                 setTimeout(() => keys[key] = false, 100);
             };
             btn.addEventListener('touchstart', (e) => { e.preventDefault(); trigger(); });
             btn.addEventListener('mousedown', (e) => { e.preventDefault(); trigger(); });
        });

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (currentState !== STATE_GAME_OVER) {
                update(deltaTime);
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            if (currentState === STATE_WORLD) updateWorld(dt);
            else if (currentState === STATE_BATTLE) updateBattleJoystick(dt);
            
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const txt = floatingTexts[i];
                txt.time -= dt;
                txt.y -= 20 * dt; 
                if (txt.time <= 0) floatingTexts.splice(i, 1);
            }

            if (shakeAmount > 0) {
                shakeAmount -= dt * 30;
                if (shakeAmount < 0) shakeAmount = 0;
            }
            if (battleCooldown > 0) {
                battleCooldown -= dt;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            if (shakeAmount > 0) {
                const dx = (Math.random() - 0.5) * shakeAmount;
                const dy = (Math.random() - 0.5) * shakeAmount;
                ctx.translate(dx, dy);
            }

            if (currentState === STATE_WORLD) drawWorld();
            else if (currentState === STATE_BATTLE) drawBattle();

            ctx.restore();
            
            if (shakeAmount > 5) {
                ctx.fillStyle = `rgba(255, 0, 0, ${shakeAmount / 40})`;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            }
        }

        function getTitle(level) {
            const index = Math.floor((level - 1) / 5);
            return TITLES[Math.min(index, TITLES.length - 1)];
        }

        // --- World Update ---
        function updateBattleJoystick(dt) {
            joystickTimer -= dt;
            if (joystickTimer > 0) return;

            if (joystickVector.y < -0.5) {
                handleBattleInput('ArrowUp');
                joystickTimer = 0.3;
            } else if (joystickVector.y > 0.5) {
                handleBattleInput('ArrowDown');
                joystickTimer = 0.3;
            }
        }

        function handleWorldInput(key) {
            if (key === 'Enter' || key === ' ') {
                const dist = Math.sqrt((player.x - coffeeMachineLoc.x)**2 + (player.y - coffeeMachineLoc.y)**2);
                if (dist < 60) {
                    player.hp = player.maxHp;
                    floatingTexts.push({
                        text: "Coffee Break! HP Maxed!",
                        x: player.x,
                        y: player.y - 30,
                        color: '#f1c40f',
                        time: 1.5
                    });
                }
            }
        }

        function updateWorld(dt) {
            let dx = joystickVector.x;
            let dy = joystickVector.y;

            if (keys['ArrowUp']) dy = -1;
            if (keys['ArrowDown']) dy = 1;
            if (keys['ArrowLeft']) dx = -1;
            if (keys['ArrowRight']) dx = 1;

            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 1) { dx /= len; dy /= len; }

            if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                const nextX = player.x + dx * player.speed * dt;
                const nextY = player.y + dy * player.speed * dt;

                // Check Exit Door Logic
                const c = Math.floor((nextX + 15) / TILE_SIZE);
                const r = Math.floor((nextY + 15) / TILE_SIZE);
                
                if (objectMap[r] && objectMap[r][c] === OBJ_EXIT_DOOR) {
                    // Check if enemies are cleared
                    if (enemies.length === 0) {
                        nextStage();
                        return; // Stop update to prevent glitching into door
                    } else {
                        // Locked
                        floatingTexts.push({
                            text: "Locked! Defeat Enemies!",
                            x: player.x,
                            y: player.y - 30,
                            color: '#e74c3c',
                            time: 0.1 // Short so it doesn't stack too much
                        });
                        return; // Treat as wall
                    }
                }

                if (!checkCollision(nextX, player.y)) player.x = nextX;
                if (!checkCollision(player.x, nextY)) player.y = nextY;
            }

            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);
                if (dist < 40 && battleCooldown <= 0) { 
                    startBattle(enemy, i);
                    break;
                }
            }
        }

        function nextStage() {
            currentStage++;
            floatingTexts.push({
                text: "STAGE CLEAR!",
                x: SCREEN_WIDTH/2,
                y: SCREEN_HEIGHT/2,
                color: '#2ecc71',
                time: 3.0
            });
            initMap();
        }

        function checkCollision(x, y) {
            const points = [
                { x: x, y: y },
                { x: x + player.width, y: y },
                { x: x, y: y + player.height },
                { x: x + player.width, y: y + player.height }
            ];

            for (let p of points) {
                const c = Math.floor(p.x / TILE_SIZE);
                const r = Math.floor(p.y / TILE_SIZE);

                if (c < 0 || c >= MAP_COLS || r < 0 || r >= MAP_ROWS) return true;
                if (worldMap[r][c] === TILE_WALL) return true;
                // Objects are solid (except Coffee machine which you can walk on/near to interact usually, but here we treat solid)
                // Treat Exit door specially (handled in updateWorld)
                if (objectMap[r][c] !== OBJ_NONE && objectMap[r][c] !== OBJ_EXIT_DOOR) return true;
            }
            return false;
        }

        function drawWorld() {
            for (let r = 0; r < MAP_ROWS; r++) {
                for (let c = 0; c < MAP_COLS; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    ctx.fillStyle = COLOR_FLOOR;
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    
                    ctx.fillStyle = 'rgba(0,0,0,0.03)';
                    if ((r+c)%2 === 0) ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                    ctx.strokeStyle = '#d0d0d0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

                    if (worldMap[r][c] === TILE_WALL) {
                        ctx.fillStyle = COLOR_WALL;
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#444';
                        ctx.fillRect(x, y + TILE_SIZE - 5, TILE_SIZE, 5);
                    }

                    const obj = objectMap[r][c];
                    if (obj !== OBJ_NONE) {
                        drawObject(ctx, x, y, obj);
                    }
                }
            }

            enemies.forEach(e => {
                drawCharacter(ctx, e.x, e.y, e.type, 1, false);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(e.x - 5, e.y - 12, e.width + 10, 10);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(e.name, e.x + e.width/2, e.y - 4);
            });

            drawCharacter(ctx, player.x, player.y, player.type, 1, false);
            
            // HUD
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(10, 10, 280, 105); // Taller for Stage Info
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 280, 105);
            
            ctx.fillStyle = '#fff';
            ctx.font = '16px Courier New';
            ctx.fillText(`${getTitle(player.level)} (Lvl ${player.level})`, 20, 35);
            ctx.fillStyle = '#FFD700'; 
            ctx.fillText(`Score: ${player.score}`, 20, 50); 
            ctx.fillStyle = '#fff';
            ctx.fillText(`Stage: ${currentStage} | Enemies: ${enemies.length}`, 20, 65);

            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(20, 80, 100, 8);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(20, 80, 100 * (player.hp / player.maxHp), 8);
            
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(130, 80, 100, 8);
            ctx.fillStyle = '#3498db';
            ctx.fillRect(130, 80, 100 * (player.xp / player.nextLevelXp), 8);
            
            ctx.font = '10px Courier New';
            ctx.fillStyle = '#fff';
            ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, 20, 100);
            ctx.fillText(`XP: ${player.xp}/${player.nextLevelXp}`, 130, 100);

            floatingTexts.forEach(txt => {
                ctx.save();
                ctx.fillStyle = txt.color;
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(txt.text, txt.x, txt.y);
                ctx.restore();
            });

            if (battleCooldown > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText("SAFE!", player.x - 10, player.y - 10);
            }
        }

        // --- Battle System ---
        let currentEnemyIndex = -1;

        function startBattle(enemy, index) {
            currentState = STATE_BATTLE;
            currentEnemyIndex = index;

            const levelScale = 1 + (player.level - 1) * 0.2;

            battleState = {
                enemy: {
                    ...enemy,
                    maxHp: Math.floor(enemy.hp), // Already scaled in spawn
                    hp: Math.floor(enemy.hp),
                    xp: Math.floor(enemy.xp)
                },
                menuSelection: 0,
                attackSelection: 0,
                phase: 'MENU',
                log: `You encountered a ${enemy.name}!`,
                turn: 'PLAYER'
            };

            joystickVector = { x: 0, y: 0 };
            keys['ArrowUp'] = false; keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false; keys['ArrowRight'] = false;
        }

        function handleBattleInput(key) {
             if (battleState.phase === 'MENU') {
                if (key === 'ArrowUp') battleState.menuSelection = (battleState.menuSelection - 1 + 3) % 3;
                if (key === 'ArrowDown') battleState.menuSelection = (battleState.menuSelection + 1) % 3;
                if (key === 'Enter' || key === ' ') {
                    if (battleState.menuSelection === 0) {
                        battleState.phase = 'ATTACK_SELECT';
                        battleState.attackSelection = 0;
                        battleState.log = "Select Attack:";
                    } else if (battleState.menuSelection === 1) attemptCatch();
                    else if (battleState.menuSelection === 2) {
                        if (Math.random() < 0.5) {
                            battleState.log = "Ran away safely!";
                            
                            const enemy = battleState.enemy;
                            let dx = player.x - enemy.x;
                            let dy = player.y - enemy.y;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist > 0) {
                                const stepDist = 60;
                                const moveX = (dx / dist) * stepDist;
                                const moveY = (dy / dist) * stepDist;
                                const newX = player.x + moveX;
                                const newY = player.y + moveY;
                                
                                if (!checkCollision(newX, newY)) {
                                    player.x = newX;
                                    player.y = newY;
                                }
                            }
                            
                            battleCooldown = 2.0;
                            battleState.phase = 'END';
                        } else {
                            battleState.log = "Failed to run!";
                            battleState.phase = 'BATTLE_ANIMATION';
                            setTimeout(enemyTurn, 1000);
                        }
                    }
                }
            } else if (battleState.phase === 'ATTACK_SELECT') {
                if (key === 'ArrowUp') battleState.attackSelection = (battleState.attackSelection - 1 + 4) % 4;
                if (key === 'ArrowDown') battleState.attackSelection = (battleState.attackSelection + 1) % 4;
                if (key === 'Escape') {
                    battleState.phase = 'MENU';
                    battleState.log = "What will you do?";
                }
                if (key === 'Enter' || key === ' ') performAttack(PLAYER_ATTACKS[battleState.attackSelection]);
            } else if (battleState.phase === 'END' || battleState.phase === 'LEVEL_UP') {
                 if (key === 'Enter' || key === ' ') {
                     if (battleState.enemy.hp <= 0 || battleState.phase === 'LEVEL_UP') {
                         if (currentEnemyIndex > -1) {
                             enemies.splice(currentEnemyIndex, 1);
                         }
                     }
                     currentState = STATE_WORLD;
                 }
            }
        }

        function performAttack(attack) {
            if (attack.heal) {
                const healAmt = 5 + Math.floor(player.level);
                player.hp = Math.min(player.maxHp, player.hp + healAmt);
                battleState.log = `Drank Coffee! +${healAmt} HP.`;
                battleState.phase = 'BATTLE_ANIMATION';
                setTimeout(enemyTurn, 1000);
                return;
            }

            let damage = attack.damage + Math.floor(player.level / 2);
            if (player.consultants > 0) damage += player.consultants;

            battleState.enemy.hp -= damage;
            battleState.log = `Used ${attack.name}! Dealt ${damage} dmg.`;
            battleState.phase = 'BATTLE_ANIMATION';

            if (battleState.enemy.hp <= 0) {
                battleState.enemy.hp = 0;
                setTimeout(() => winBattle(), 1000);
            } else {
                setTimeout(enemyTurn, 1000);
            }
        }

        function attemptCatch() {
            if (battleState.enemy.name === "Consultant") {
                if (Math.random() < 0.6) {
                    player.consultants++;
                    battleState.log = "Hired Consultant!";
                    battleState.phase = 'END';
                    battleState.enemy.hp = 0; 
                } else {
                    battleState.log = "Offer refused!";
                    battleState.phase = 'BATTLE_ANIMATION';
                    setTimeout(enemyTurn, 1000);
                }
            } else {
                battleState.log = "Can only hire Consultants!";
                battleState.phase = 'BATTLE_ANIMATION';
                setTimeout(() => { battleState.phase = 'MENU'; battleState.log = "Action?"; }, 1000);
            }
        }

        function enemyTurn() {
            if (currentState !== STATE_BATTLE) return;
            
            const moves = ENEMY_MOVES[battleState.enemy.type] || ENEMY_MOVES["Consultant"];
            const move = moves[Math.floor(Math.random() * moves.length)];
            
            const levelScale = 1 + (player.level * 0.1);
            let damage = Math.floor(move.damage * levelScale);
            
            damage = Math.floor(damage * (0.8 + Math.random() * 0.4));
            if (damage < 1) damage = 1;

            player.hp -= damage;
            battleState.log = `${battleState.enemy.name} used ${move.name}! -${damage} HP.`;
            
            shakeAmount = 20;

            if (player.hp <= 0) {
                player.hp = 0;
                currentState = STATE_GAME_OVER;
                document.getElementById('final-score').innerText = `Score: ${player.score}`;
                document.getElementById('game-over-modal').classList.remove('hidden');
                battleState.phase = 'GAME_OVER';
            } else {
                battleState.phase = 'MENU';
            }
        }

        function winBattle() {
            const xpGain = battleState.enemy.xp;
            player.xp += xpGain;
            const scoreGain = battleState.enemy.maxHp * 10;
            player.score += scoreGain;
            battleState.log = `Win! +${xpGain} XP. +${scoreGain} Pts.`;
            if (player.xp >= player.nextLevelXp) setTimeout(() => levelUp(), 1000);
            else battleState.phase = 'END';
        }

        function levelUp() {
            player.level++;
            player.xp -= player.nextLevelXp;
            player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5);
            player.maxHp += 5;
            player.hp = player.maxHp;
            battleState.log = `Promoted to ${getTitle(player.level)}!`;
            battleState.phase = 'LEVEL_UP';
        }

        function restartGame() {
            player.level = 1;
            player.hp = 20;
            player.maxHp = 20;
            player.xp = 0;
            player.nextLevelXp = 50;
            player.score = 0;
            player.consultants = 0;
            currentStage = 1;

            document.getElementById('game-over-modal').classList.add('hidden');
            initMap();
            currentState = STATE_WORLD;
            draw();
        }

        function drawBattle() {
            const grad = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT);
            grad.addColorStop(0, '#2c3e50');
            grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.ellipse(SCREEN_WIDTH/2, 350, 350, 100, 0, 0, Math.PI*2);
            ctx.fill();

            const enemy = battleState.enemy;
            drawCharacter(ctx, 500, 100, enemy.type, 4, false);

            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`${enemy.name} (Lvl ${player.level})`, 450, 80);
            
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.roundRect(450, 90, 200, 15, 5);
            ctx.fill();
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.roundRect(450, 90, 200 * (enemy.hp / enemy.maxHp), 15, 5);
            ctx.fill();

            drawCharacter(ctx, 150, 200, player.type, 4, true);

            ctx.fillStyle = 'white';
            ctx.fillText(`${getTitle(player.level)}`, 100, 230);
            
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.roundRect(100, 240, 200, 15, 5);
            ctx.fill();
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.roundRect(100, 240, 200 * (player.hp / player.maxHp), 15, 5);
            ctx.fill();
            
            ctx.font = '16px Courier New';
            ctx.fillText(`${player.hp} / ${player.maxHp} HP`, 100, 275);

            ctx.fillStyle = COLOR_MENU_BG;
            ctx.fillRect(0, 400, SCREEN_WIDTH, 200);
            ctx.strokeStyle = COLOR_MENU_BORDER;
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 405, SCREEN_WIDTH - 10, 190);

            ctx.fillStyle = 'white';
            ctx.font = '24px Courier New';
            ctx.fillText(battleState.log, 30, 450);

            const startX = 500;
            const startY = 480;

            if (battleState.phase === 'MENU') {
                const options = ["FIGHT", "HIRE", "RUN"];
                options.forEach((opt, index) => {
                    if (index === battleState.menuSelection) {
                        ctx.fillStyle = '#f1c40f';
                        ctx.fillText(`> ${opt}`, startX, startY + index * 40);
                    } else {
                        ctx.fillStyle = 'white';
                        ctx.fillText(`  ${opt}`, startX, startY + index * 40);
                    }
                });
            } else if (battleState.phase === 'ATTACK_SELECT') {
                PLAYER_ATTACKS.forEach((att, index) => {
                    if (index === battleState.attackSelection) {
                         ctx.fillStyle = '#f1c40f';
                        ctx.fillText(`> ${att.name}`, startX, startY + index * 30 - 20);
                    } else {
                         ctx.fillStyle = 'white';
                        ctx.fillText(`  ${att.name}`, startX, startY + index * 30 - 20);
                    }
                });
            } else if (battleState.phase === 'END' || battleState.phase === 'LEVEL_UP') {
                 ctx.fillStyle = '#f1c40f';
                 ctx.fillText("Press A to continue...", startX, startY + 40);
            }
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

