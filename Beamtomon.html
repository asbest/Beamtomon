<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beamtomon: Office Editions (Pause Fixed)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent browser zooming/scrolling globally */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background: #202020;
        }

        /* --- UI Panel (Top) --- */
        #ui-panel {
            flex: 0 0 auto; 
            background-color: #2c3e50;
            border-bottom: 4px solid #fff;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            /* Z-Index increased to be higher than controls (20) */
            z-index: 50; 
            position: relative;
            font-size: 14px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .ui-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; 
        }

        .ui-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bar-container {
            width: 80px;
            height: 8px;
            background: #555;
            border: 1px solid #fff;
            position: relative;
        }

        .bar-fill { height: 100%; transition: width 0.2s; }
        .hp-fill { background-color: #e74c3c; } 
        .xp-fill { background-color: #3498db; }

        #ui-score { color: #f1c40f; font-weight: bold; }
        #ui-signatures { color: #2ecc71; font-weight: bold; text-transform: uppercase; }
        #ui-donuts { color: #e67e22; }

        /* Pause Button */
        #pause-btn {
            background: #e67e22;
            color: white;
            border: 2px solid #fff;
            padding: 8px 12px; /* Larger touch target */
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            margin-left: 10px;
            touch-action: manipulation;
            pointer-events: auto; /* Ensure it receives clicks */
        }
        #pause-btn:active { background: #d35400; transform: translateY(1px); }

        /* --- Canvas Wrapper --- */
        #canvas-wrapper {
            flex: 1 1 auto; 
            position: relative;
            background: #000;
            overflow: hidden;
            width: 100%; 
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }

        /* Virtual Controls */
        .controls-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .joystick-area {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
            transition: opacity 0.3s;
        }
        
        .joystick-area:active { background: rgba(255, 255, 255, 0.2); }

        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .actions {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            pointer-events: auto;
        }

        .action-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 28px;
            touch-action: manipulation;
            transition: transform 0.1s;
        }

        .action-btn:active { background: rgba(0, 255, 0, 0.4); transform: scale(0.95); }

        /* --- Modals --- */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .hidden { display: none !important; }

        .modal-content {
            background: #2c3e50;
            padding: 30px;
            border: 4px solid #fff;
            border-radius: 10px;
            text-align: center;
            min-width: 250px;
            max-width: 80%;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-title { font-size: 32px; color: #e74c3c; margin-bottom: 5px; }
        .modal-score { font-size: 20px; color: #f1c40f; }

        .menu-btn {
            background: #34495e;
            color: white;
            border: 2px solid #fff;
            padding: 12px 20px;
            font-size: 18px;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border-radius: 5px;
            pointer-events: auto;
            touch-action: manipulation;
            transition: background 0.1s;
        }
        
        .menu-btn:hover { background: #3e5871; }
        .menu-btn:active { background: #2c3e50; transform: translateY(2px); }
        .menu-btn.primary { background: #27ae60; }
        .menu-btn.primary:hover { background: #2ecc71; }
        .menu-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        #toast-msg {
            position: absolute;
            top: 60px; /* Moved down slightly */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #f1c40f;
            padding: 10px 20px;
            border: 1px solid #fff;
            border-radius: 20px;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- UI Panel -->
        <div id="ui-panel">
            <div class="ui-row" style="margin-bottom: 5px;">
                <span id="ui-name">Intern (Lvl 1)</span>
                <div class="ui-group">
                    <button id="pause-btn">PAUSE</button>
                    <span id="ui-score">0 Pts</span>
                    <span id="ui-stage" style="color:#aaa;">Stg 1</span>
                </div>
            </div>
            <div class="ui-row">
                <div class="ui-group">
                    <div style="width: 40px;">Sanity</div>
                    <div class="bar-container"><div id="bar-hp" class="bar-fill hp-fill" style="width: 100%;"></div></div>
                </div>
                <span id="ui-signatures">SIGS: 0/3</span>
            </div>
            <div class="ui-row" style="margin-top: 2px;">
                <div class="ui-group">
                    <div style="width: 40px;">XP</div>
                    <div class="bar-container"><div id="bar-xp" class="bar-fill xp-fill" style="width: 0%;"></div></div>
                </div>
                <span id="ui-donuts">üç© x1</span>
            </div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <div id="toast-msg">Game Saved!</div>

            <!-- Pause Menu -->
            <div id="pause-modal" class="modal-overlay hidden">
                <div class="modal-content">
                    <div class="modal-title" style="color: #e67e22;">PAUSED</div>
                    <button id="resume-btn" class="menu-btn primary">Resume</button>
                    <button id="save-btn" class="menu-btn">Save Game</button>
                    <button id="load-btn" class="menu-btn">Load Game</button>
                    <button id="quit-btn" class="menu-btn" style="background:#c0392b;">Reset</button>
                </div>
            </div>

            <!-- Game Over Menu -->
            <div id="game-over-modal" class="modal-overlay hidden">
                <div class="modal-content">
                    <div class="modal-title">BURNOUT!</div>
                    <div class="modal-score" id="final-score">Score: 0</div>
                    <button id="restart-btn" class="menu-btn primary">Back to Work</button>
                </div>
            </div>

            <div class="controls-container">
                <div class="joystick-area" id="joystick">
                    <div class="joystick-knob" id="joystick-knob"></div>
                </div>
                <div class="actions">
                    <div class="action-btn" data-key="Enter">A</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Sound System (Web Audio API) ---
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return; 
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'action') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'attack') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'heal') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'defeat') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.8);
                const lfo = audioCtx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 10;
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 20;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(now);
                lfo.stop(now + 0.8);

                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.8);
                osc.start(now);
                osc.stop(now + 0.8);
            } else if (type === 'victory') {
                const now = audioCtx.currentTime;
                playNote(600, now, 0.1);
                playNote(800, now + 0.1, 0.1);
                playNote(1000, now + 0.2, 0.2);
            }
        }

        function playNote(freq, time, dur) {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g);
            g.connect(audioCtx.destination);
            o.frequency.value = freq;
            o.type = 'square';
            g.gain.setValueAtTime(0.1, time);
            g.gain.linearRampToValueAtTime(0, time + dur);
            o.start(time);
            o.stop(time + dur);
        }

        // Game Constants
        const TILE_SIZE = 40;
        const SCREEN_WIDTH = 800;
        const SCREEN_HEIGHT = 600;
        const MAP_COLS = SCREEN_WIDTH / TILE_SIZE;
        const MAP_ROWS = SCREEN_HEIGHT / TILE_SIZE;

        const TILE_FLOOR = 0;
        const TILE_WALL = 1;

        const OBJ_NONE = 0;
        const OBJ_DESK = 1;
        const OBJ_CHAIR = 2;
        const OBJ_PLANT = 3;
        const OBJ_PRINTER = 4;
        const OBJ_COFFEE_MACHINE = 5;
        const OBJ_EXIT_DOOR = 6; 

        // Colors
        const COLOR_FLOOR = '#e0e0e0';
        const COLOR_WALL = '#555555';
        const COLOR_MENU_BG = '#303030';
        const COLOR_MENU_BORDER = '#ffffff';

        const FACT_OFFICER = 'OFFICER';     
        const FACT_POLITICIAN = 'POLITICIAN'; 
        const FACT_CITIZEN = 'CITIZEN';     
        const FACT_NEUTRAL = 'NEUTRAL'; 

        function getTypeEffectiveness(attackerType, defenderType) {
            if (attackerType === FACT_OFFICER && defenderType === FACT_CITIZEN) return 1.5;
            if (attackerType === FACT_CITIZEN && defenderType === FACT_POLITICIAN) return 1.5;
            if (attackerType === FACT_POLITICIAN && defenderType === FACT_OFFICER) return 1.5;
            if (attackerType === FACT_OFFICER && defenderType === FACT_POLITICIAN) return 0.5;
            if (attackerType === FACT_CITIZEN && defenderType === FACT_OFFICER) return 0.5;
            if (attackerType === FACT_POLITICIAN && defenderType === FACT_CITIZEN) return 0.5;
            return 1.0;
        }

        const STATE_WORLD = 'WORLD';
        const STATE_BATTLE = 'BATTLE';
        const STATE_GAME_OVER = 'GAME_OVER';
        const STATE_PAUSED = 'PAUSED';

        let currentState = STATE_WORLD;
        let shakeAmount = 0;
        let battleCooldown = 0; 
        let battleState = null; 
        
        let currentStage = 1;
        let mapSeedVal = 100;

        function prng() {
            var x = Math.sin(mapSeedVal++) * 10000;
            return x - Math.floor(x);
        }

        const keys = {};
        let joystickVector = { x: 0, y: 0 };
        let joystickTimer = 0;

        let floatingTexts = [];

        let player = {
            x: 100,
            y: 100,
            width: 30,
            height: 30,
            speed: 200,
            color: '#3498db',
            type: "Beamter",
            name: "Player",
            dept: FACT_OFFICER, 
            level: 1,
            hp: 20,
            maxHp: 20,
            xp: 0,
            nextLevelXp: 50,
            score: 0,
            signatures: 0,
            inventory: { donuts: 1 },
            status: null,
            isWalking: false,
            consultants: [] 
        };

        const SIGNATURES_NEEDED = 3;

        let coffeeMachineLoc = { x: 0, y: 0 };
        let exitDoorLoc = { x: 0, y: 0 };

        const TITLES = ["Intern", "Junior Associate", "Senior Associate", "Manager", "Director"];
        
        const PLAYER_ATTACKS = [
            { name: "Permission Denied", damage: 4, type: FACT_OFFICER, effect: "STUN", chance: 0.3 }, 
            { name: "Pass the Buck", damage: 6, type: FACT_POLITICIAN },
            { name: "Form A38", damage: 8, type: FACT_OFFICER, effect: "CONFUSE", chance: 0.3 } 
        ];

        const ENEMY_MOVES = {
            "Consultant": [
                { name: "Synergy Strike", damage: 5, type: FACT_POLITICIAN },
                { name: "Mass Layoff", damage: 9, type: FACT_POLITICIAN },
                { name: "Buzzword Blast", damage: 3, type: FACT_POLITICIAN, effect: "CONFUSE", chance: 0.5 },
                { name: "Circle Back", damage: 4, type: FACT_OFFICER }
            ],
            "Politician": [
                { name: "Empty Promise", damage: 2, type: FACT_POLITICIAN },
                { name: "Tax Hike", damage: 7, type: FACT_OFFICER },
                { name: "Filibuster", damage: 4, type: FACT_POLITICIAN, effect: "STUN", chance: 0.5 },
                { name: "Scandal", damage: 8, type: FACT_POLITICIAN }
            ],
            "Citizen": [
                { name: "Complaint", damage: 3, type: FACT_CITIZEN },
                { name: "Angry Email", damage: 4, type: FACT_CITIZEN },
                { name: "Phone Call", damage: 2, type: FACT_CITIZEN },
                { name: "Form Request", damage: 1, type: FACT_CITIZEN }
            ],
            "Colleague": [
                { name: "Reply All", damage: 5, type: FACT_OFFICER },
                { name: "Gossip", damage: 3, type: FACT_NEUTRAL },
                { name: "Microwave Fish", damage: 6, type: FACT_NEUTRAL, effect: "NAUSEA", chance: 1.0 }, 
                { name: "Meeting Invite", damage: 4, type: FACT_OFFICER, effect: "STUN", chance: 0.3 }
            ]
        };
        
        const ENEMY_TYPES = [
            { name: "Consultant", dept: FACT_POLITICIAN, color: "#f1c40f", shirt: "#f1c40f", pants: "#2c3e50", hp: 15, xp: 20 },
            { name: "Politician", dept: FACT_POLITICIAN, color: "#9b59b6", shirt: "#8e44ad", pants: "#2c3e50", hp: 25, xp: 30 },
            { name: "Citizen", dept: FACT_CITIZEN, color: "#2ecc71", shirt: "#27ae60", pants: "#ecf0f1", hp: 10, xp: 10 },
            { name: "Colleague", dept: FACT_OFFICER, color: "#95a5a6", shirt: "#7f8c8d", pants: "#34495e", hp: 20, xp: 25 }
        ];

        let worldMap = [];
        let objectMap = [];
        let enemies = [];
        let lootedObjects = []; 

        function getActiveFighter() {
            if (!battleState || battleState.fighterIndex === -1) return player;
            return player.consultants[battleState.fighterIndex];
        }

        function updateHUD() {
            const fighter = (currentState === STATE_BATTLE && battleState) ? getActiveFighter() : player;
            
            let nameDisplay = "";
            if (fighter === player) {
                nameDisplay = `${getTitle(player.level)} (Lvl ${player.level})`;
            } else {
                nameDisplay = `${fighter.name} (Lvl ${fighter.level})`;
            }

            document.getElementById('ui-name').innerText = nameDisplay;
            document.getElementById('ui-score').innerText = `${player.score} Pts`;
            document.getElementById('ui-stage').innerText = `Stg ${currentStage}`;
            
            const sigs = document.getElementById('ui-signatures');
            sigs.innerText = `SIGS: ${player.signatures}/${SIGNATURES_NEEDED}`;
            sigs.style.color = player.signatures >= SIGNATURES_NEEDED ? '#2ecc71' : '#e74c3c';

            document.getElementById('ui-donuts').innerText = `üç© x${player.inventory.donuts}`;
            
            document.getElementById('bar-hp').style.width = `${Math.max(0, Math.min(100, (fighter.hp / fighter.maxHp) * 100))}%`;
            const xpPct = fighter.nextLevelXp ? (fighter.xp / fighter.nextLevelXp) * 100 : 0;
            document.getElementById('bar-xp').style.width = `${Math.max(0, Math.min(100, xpPct))}%`;
        }

        // --- Drawing Helpers ---

        function circle(ctx, x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCharacter(ctx, x, y, type, scale = 1, isBack = false, animOffset = 0, status = null, isWalking = false, rotation = 0, xOffset = 0, yOffset = 0) {
            const w = 30 * scale;
            const h = 30 * scale;
            const cx = x + w / 2;
            const cy = y + h / 2;

            ctx.save();
            ctx.translate(cx + xOffset, cy + yOffset);
            ctx.rotate(rotation);
            ctx.translate(-cx, -cy);

            const bobSpeed = isWalking ? 100 : 250;
            const bobAmt = isWalking ? 3 : 1;
            const drawY = y + Math.sin(Date.now() / bobSpeed) * (bobAmt * scale);

            let legOffsetL = 0;
            let legOffsetR = 0;
            if (isWalking) {
                const t = Date.now() / 100;
                legOffsetL = Math.sin(t) * (3 * scale);
                legOffsetR = Math.sin(t + Math.PI) * (3 * scale);
            }

            let skinColor = '#ffdbac';
            let shirtColor = '#3498db';
            let pantsColor = '#2c3e50';
            let hairColor = '#5d4037';
            let hasTie = true;
            let hasGlasses = true;

            if (type === "Consultant") {
                shirtColor = '#f1c40f'; pantsColor = '#34495e'; hairColor = '#f39c12'; hasGlasses = false;
            } else if (type === "Politician") {
                shirtColor = '#8e44ad'; pantsColor = '#2c3e50'; hairColor = '#bdc3c7'; hasTie = true;
            } else if (type === "Citizen") {
                shirtColor = '#2ecc71'; pantsColor = '#95a5a6'; hasTie = false; hasGlasses = false;
            } else if (type === "Colleague") {
                shirtColor = '#95a5a6'; pantsColor = '#34495e';
            }

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, y + h - 2*scale, w/2, h/6, 0, 0, Math.PI*2);
            ctx.fill();

            if (status) {
                if (status.type === 'NAUSEA') ctx.filter = 'hue-rotate(90deg)';
                if (status.type === 'STUN') ctx.filter = 'brightness(0.5)';
            }

            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + w*0.2, drawY + h*0.4, w*0.6, h*0.4);

            ctx.fillStyle = pantsColor;
            ctx.fillRect(x + w*0.25, drawY + h*0.75 + legOffsetL, w*0.2, h*0.25);
            ctx.fillRect(x + w*0.55, drawY + h*0.75 + legOffsetR, w*0.2, h*0.25);

            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.arc(cx, drawY + h*0.25, w*0.3, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = hairColor;
            ctx.beginPath();
            if (isBack) {
                ctx.arc(cx, drawY + h*0.25, w*0.32, Math.PI, Math.PI*2); 
                ctx.fillRect(x + w*0.2, drawY + h*0.25, w*0.6, h*0.2); 
            } else {
                ctx.arc(cx, drawY + h*0.22, w*0.32, Math.PI*1.1, Math.PI*1.9);
            }
            ctx.fill();

            if (!isBack) {
                ctx.fillStyle = 'black';
                if (hasGlasses) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1 * scale;
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(cx - w*0.15, drawY + h*0.2, w*0.12, h*0.1);
                    ctx.strokeRect(cx - w*0.15, drawY + h*0.2, w*0.12, h*0.1);
                    ctx.fillRect(cx + w*0.03, drawY + h*0.2, w*0.12, h*0.1);
                    ctx.strokeRect(cx + w*0.03, drawY + h*0.2, w*0.12, h*0.1);
                } else {
                    ctx.fillRect(cx - w*0.12, drawY + h*0.22, 2*scale, 2*scale);
                    ctx.fillRect(cx + w*0.08, drawY + h*0.22, 2*scale, 2*scale);
                }

                if (hasTie) {
                    ctx.fillStyle = '#c0392b';
                    ctx.beginPath();
                    ctx.moveTo(cx, drawY + h*0.4);
                    ctx.lineTo(cx + w*0.05, drawY + h*0.6);
                    ctx.lineTo(cx, drawY + h*0.65);
                    ctx.lineTo(cx - w*0.05, drawY + h*0.6);
                    ctx.fill();
                }
            }
            
            ctx.fillStyle = shirtColor;
            ctx.beginPath();
            const armSwing = isWalking ? Math.sin(Date.now() / 100) * (3*scale) : 0;
            ctx.ellipse(x + w*0.1, drawY + h*0.5 + armSwing, w*0.1, h*0.2, 0, 0, Math.PI*2);
            ctx.ellipse(x + w*0.9, drawY + h*0.5 - armSwing, w*0.1, h*0.2, 0, 0, Math.PI*2);
            ctx.fill();
            
            ctx.filter = 'none';
            if (status) {
                ctx.font = `bold ${10*scale}px Arial`;
                ctx.textAlign = 'center';
                let text = "";
                if (status.type === 'NAUSEA') text = "ü§¢";
                if (status.type === 'STUN') text = "üòµ";
                if (status.type === 'CONFUSE') text = "‚ùì";
                ctx.fillText(text, cx, drawY - h*0.2);
            }

            ctx.restore();
        }

        function drawObject(ctx, x, y, type, looted) {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(x + 2, y + TILE_SIZE - 5, TILE_SIZE - 4, 4);

            if (type === OBJ_DESK) {
                ctx.fillStyle = '#5d4037'; ctx.fillRect(x + 5, y + 15, 5, 20); ctx.fillRect(x + 30, y + 15, 5, 20);
                ctx.fillStyle = '#8d6e63'; ctx.fillRect(x + 2, y + 10, 36, 12);
                ctx.fillStyle = '#795548'; ctx.fillRect(x + 2, y + 22, 36, 3);
                if (!looted) {
                    ctx.fillStyle = 'white'; ctx.fillRect(x + 8, y + 12, 8, 6);
                    ctx.fillStyle = '#ddd'; ctx.fillRect(x + 10, y + 11, 8, 6);
                }
            } else if (type === OBJ_CHAIR) {
                ctx.fillStyle = '#333'; ctx.fillRect(x + 12, y + 25, 3, 10); ctx.fillRect(x + 25, y + 25, 3, 10);
                ctx.fillStyle = '#222'; ctx.fillRect(x + 10, y + 20, 20, 5);
                ctx.fillStyle = '#111'; ctx.fillRect(x + 10, y + 5, 20, 15);
            } else if (type === OBJ_PLANT) {
                ctx.fillStyle = '#d35400';
                ctx.beginPath(); ctx.moveTo(x + 10, y + 35); ctx.lineTo(x + 30, y + 35); ctx.lineTo(x + 32, y + 20); ctx.lineTo(x + 8, y + 20); ctx.fill();
                circle(ctx, x + 20, y + 15, 8, '#27ae60'); 
                if(!looted) { 
                    circle(ctx, x + 12, y + 18, 6, '#2ecc71'); circle(ctx, x + 28, y + 18, 6, '#2ecc71'); circle(ctx, x + 20, y + 8, 7, '#2ecc71');
                }
            } else if (type === OBJ_PRINTER) {
                ctx.fillStyle = '#bdc3c7'; ctx.fillRect(x + 5, y + 10, 30, 20);
                ctx.fillStyle = '#7f8c8d'; ctx.fillRect(x + 5, y + 10, 30, 5);
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(x + 10, y + 10); ctx.lineTo(x + 15, y + 5); ctx.lineTo(x + 25, y + 5); ctx.lineTo(x + 30, y + 10); ctx.fill();
                ctx.fillStyle = '#2ecc71'; ctx.fillRect(x + 28, y + 12, 3, 3);
            } else if (type === OBJ_COFFEE_MACHINE) {
                ctx.fillStyle = '#555'; ctx.fillRect(x+5, y+20, 30, 15);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(x+10, y+5, 20, 25);
                ctx.fillStyle = '#000'; ctx.fillRect(x+9, y+5, 22, 5);
                ctx.fillStyle = '#444'; ctx.fillRect(x+12, y+15, 16, 12);
                ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(x+14, y+17, 12, 10);
                ctx.fillStyle = '#3e2723'; ctx.fillRect(x+15, y+20, 10, 7);
                ctx.fillStyle = 'red'; ctx.fillRect(x+25, y+8, 2, 2);
            } else if (type === OBJ_EXIT_DOOR) {
                const locked = player.signatures < SIGNATURES_NEEDED;
                ctx.fillStyle = locked ? '#c0392b' : '#2ecc71'; 
                ctx.fillRect(x + 5, y + 5, 30, 35);
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(x + 5, y + 5, 30, 35);
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(x + 28, y + 25, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = "bold 14px Arial";
                ctx.fillText(locked ? "X" : "‚Üë", x+15, y+20);
            }
        }

        // --- Map Generation ---
        function initMap(preserveEntities = false) {
            // Seed logic: If we are loading a game, we rely on the restored mapSeedVal.
            // If new level, we set based on stage.
            if (!preserveEntities) {
                 mapSeedVal = 100 + currentStage * 997; 
                 enemies.length = 0;
                 lootedObjects.length = 0; 
                 player.signatures = 0;
            } else {
                 // For loading, we want to regenerate the terrain using the base seed for this stage
                 // but NOT reset enemies/looted.
                 // We must reset the seed to the start of the stage to get identical terrain.
                 mapSeedVal = 100 + currentStage * 997; 
            }

            worldMap = [];
            objectMap = [];

            for (let r = 0; r < MAP_ROWS; r++) {
                const row = new Array(MAP_COLS).fill(TILE_WALL);
                const objRow = new Array(MAP_COLS).fill(OBJ_NONE);
                worldMap.push(row);
                objectMap.push(objRow);
            }

            const stack = [];
            const startR = 1;
            const startC = 1;
            worldMap[startR][startC] = TILE_FLOOR;
            stack.push({r: startR, c: startC});
            let floorTiles = [];

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                const directions = [{dr: -2, dc: 0}, {dr: 2, dc: 0}, {dr: 0, dc: -2}, {dr: 0, dc: 2}];

                for (let d of directions) {
                    const nr = current.r + d.dr;
                    const nc = current.c + d.dc;
                    if (nr > 0 && nr < MAP_ROWS - 1 && nc > 0 && nc < MAP_COLS - 1) {
                        if (worldMap[nr][nc] === TILE_WALL) {
                            neighbors.push({r: nr, c: nc, linkR: current.r + d.dr/2, linkC: current.c + d.dc/2});
                        }
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(prng() * neighbors.length)];
                    worldMap[next.linkR][next.linkC] = TILE_FLOOR;
                    worldMap[next.r][next.c] = TILE_FLOOR;
                    floorTiles.push({r: next.r, c: next.c}); 
                    stack.push({r: next.r, c: next.c});
                } else {
                    stack.pop();
                }
            }

            const numRooms = 5;
            for (let i = 0; i < numRooms; i++) {
                const w = Math.floor(prng() * 3) + 3;
                const h = Math.floor(prng() * 3) + 3;
                const r = Math.floor(prng() * (MAP_ROWS - h - 2)) + 1;
                const c = Math.floor(prng() * (MAP_COLS - w - 2)) + 1;

                for (let rr = r; rr < r + h; rr++) {
                    for (let cc = c; cc < c + w; cc++) {
                        const wasWall = worldMap[rr][cc] === TILE_WALL;
                        worldMap[rr][cc] = TILE_FLOOR;
                        if (wasWall) {
                             if (prng() < 0.4) {
                                const roll = prng();
                                if (roll < 0.4) objectMap[rr][cc] = OBJ_DESK;
                                else if (roll < 0.6) objectMap[rr][cc] = OBJ_CHAIR;
                                else if (roll < 0.8) objectMap[rr][cc] = OBJ_PLANT;
                                else objectMap[rr][cc] = OBJ_PRINTER;
                            } else {
                                objectMap[rr][cc] = OBJ_NONE;
                            }
                        } else {
                            objectMap[rr][cc] = OBJ_NONE;
                        }
                    }
                }
            }

            if (floorTiles.length > 0) {
                let exitNode = floorTiles[floorTiles.length - 1]; 
                objectMap[exitNode.r][exitNode.c] = OBJ_EXIT_DOOR;
                exitDoorLoc = { r: exitNode.r, c: exitNode.c };
            }

            let coffeePlaced = false;
            let coffeeAttempts = 0;
            while (!coffeePlaced && coffeeAttempts < 500) {
                const r = Math.floor(prng() * (MAP_ROWS - 2)) + 1;
                const c = Math.floor(prng() * (MAP_COLS - 2)) + 1;
                if (worldMap[r][c] === TILE_FLOOR && objectMap[r][c] === OBJ_NONE) {
                    objectMap[r][c] = OBJ_COFFEE_MACHINE;
                    coffeeMachineLoc = { x: c * TILE_SIZE + TILE_SIZE/2, y: r * TILE_SIZE + TILE_SIZE/2 };
                    coffeePlaced = true;
                }
                coffeeAttempts++;
            }

            if (!preserveEntities) {
                let spawnFound = false;
                for(let r=1; r<MAP_ROWS; r++) {
                    for(let c=1; c<MAP_COLS; c++) {
                        if(worldMap[r][c] === TILE_FLOOR && objectMap[r][c] === OBJ_NONE) {
                            player.x = c * TILE_SIZE + 5;
                            player.y = r * TILE_SIZE + 5;
                            objectMap[r][c] = OBJ_NONE;
                            if (c+1 < MAP_COLS) objectMap[r][c+1] = OBJ_NONE;
                            spawnFound = true;
                            break;
                        }
                    }
                    if(spawnFound) break;
                }

                const enemyCount = 8 + currentStage * 2;
                for (let i = 0; i < enemyCount; i++) {
                    spawnEnemy();
                }
            } else {
                // Ensure player start position is clear if loading
                const pr = Math.floor((player.y+15)/TILE_SIZE);
                const pc = Math.floor((player.x+15)/TILE_SIZE);
                if (objectMap[pr] && objectMap[pr][pc]) objectMap[pr][pc] = OBJ_NONE;
            }
            updateHUD(); 
        }

        function spawnEnemy() {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 100) {
                const r = Math.floor(prng() * (MAP_ROWS - 2)) + 1;
                const c = Math.floor(prng() * (MAP_COLS - 2)) + 1;
                const x = c * TILE_SIZE + 5;
                const y = r * TILE_SIZE + 5;
                attempts++;

                if (worldMap[r][c] !== TILE_WALL && objectMap[r][c] === OBJ_NONE) {
                    const dx = x - player.x;
                    const dy = y - player.y;
                    if (dx*dx + dy*dy > 10000) {
                        const type = ENEMY_TYPES[Math.floor(prng() * ENEMY_TYPES.length)];
                        enemies.push({
                            ...type,
                            type: type.name === "Consultant" ? "Consultant" : 
                                  type.name === "Politician" ? "Politician" :
                                  type.name === "Citizen" ? "Citizen" : "Colleague",
                            x: x,
                            y: y,
                            maxHp: type.hp + currentStage * 2,
                            hp: type.hp + currentStage * 2,
                            xp: type.xp + currentStage * 5,
                            level: 1 + Math.floor(currentStage/2), 
                            nextLevelXp: 50,
                            id: Math.random(),
                            status: null,
                            rotation: 0,
                            shakeX: 0,
                            yOffset: 0
                        });
                        placed = true;
                    }
                }
            }
        }

        initMap();

        // --- Input Handling ---

        window.addEventListener('keydown', (e) => {
            initAudio();
            if (currentState === STATE_GAME_OVER) return;
            if (keys[e.key]) return;
            keys[e.key] = true;
            if (currentState === STATE_PAUSED) return; // Block input when paused
            if (currentState === STATE_BATTLE) handleBattleInput(e.key);
            else if (currentState === STATE_WORLD) handleWorldInput(e.key);
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joystick-knob');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        const maxRadius = 50;

        function handleStart(e) {
            initAudio();
            if (currentState === STATE_GAME_OVER || currentState === STATE_PAUSED) return;
            e.preventDefault();
            joystickActive = true;
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            handleMove(e);
        }

        function handleMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const dx = clientX - joystickCenter.x;
            const dy = clientY - joystickCenter.y;
            const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
            const angle = Math.atan2(dy, dx);

            const knobX = Math.cos(angle) * distance;
            const knobY = Math.sin(angle) * distance;

            knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            joystickVector.x = knobX / maxRadius;
            joystickVector.y = knobY / maxRadius;
        }

        function handleEnd(e) {
            e.preventDefault();
            joystickActive = false;
            joystickVector = { x: 0, y: 0 };
            knob.style.transform = `translate(-50%, -50%)`;
        }

        joystick.addEventListener('mousedown', handleStart);
        joystick.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        document.querySelectorAll('.action-btn').forEach(btn => {
             const key = btn.getAttribute('data-key');
             const trigger = () => {
                 initAudio();
                 if (currentState === STATE_GAME_OVER || currentState === STATE_PAUSED) return;
                 if (currentState === STATE_BATTLE) handleBattleInput(key);
                 else if (currentState === STATE_WORLD) handleWorldInput(key);
                 keys[key] = true;
                 setTimeout(() => keys[key] = false, 100);
             };
             btn.addEventListener('touchstart', (e) => { e.preventDefault(); trigger(); });
             btn.addEventListener('mousedown', (e) => { e.preventDefault(); trigger(); });
        });

        document.getElementById('restart-btn').addEventListener('click', restartGame);
        
        // --- Pause & Menu Logic ---

        const pauseBtn = document.getElementById('pause-btn');
        const pauseModal = document.getElementById('pause-modal');
        const resumeBtn = document.getElementById('resume-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const quitBtn = document.getElementById('quit-btn');
        const toastMsg = document.getElementById('toast-msg');

        // Robust button binder helper
        function bindButton(btn, callback) {
            if (!btn) return;
            // Prevent default to stop mouse emulation and ghost clicks
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation(); // Stop bubbling to game controls
                initAudio();
                callback();
            }, { passive: false });
            
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                initAudio();
                callback();
            });
        }

        bindButton(pauseBtn, togglePause);
        bindButton(resumeBtn, togglePause);
        
        function showToast(msg) {
            toastMsg.innerText = msg;
            toastMsg.style.opacity = 1;
            setTimeout(() => { toastMsg.style.opacity = 0; }, 2000);
        }

        function togglePause() {
            if (currentState === STATE_GAME_OVER) return;
            
            if (currentState === STATE_PAUSED) {
                // Unpause
                currentState = previousState;
                pauseModal.classList.add('hidden');
            } else {
                // Pause
                previousState = currentState;
                currentState = STATE_PAUSED;
                pauseModal.classList.remove('hidden');
                
                // Disable save if in battle
                if (previousState === STATE_BATTLE) {
                    saveBtn.disabled = true;
                    saveBtn.innerText = "Save (World Only)";
                } else {
                    saveBtn.disabled = false;
                    saveBtn.innerText = "Save Game";
                }
            }
        }

        bindButton(saveBtn, () => {
            if (previousState === STATE_BATTLE) return;
            
            const saveData = {
                player: player,
                enemies: enemies,
                lootedObjects: lootedObjects,
                currentStage: currentStage,
                mapSeedVal: mapSeedVal
            };
            localStorage.setItem('beamtomon_save', JSON.stringify(saveData));
            showToast("Game Saved!");
        });

        bindButton(loadBtn, () => {
            const saveString = localStorage.getItem('beamtomon_save');
            if (!saveString) {
                showToast("No Save Found!");
                return;
            }

            try {
                const saveData = JSON.parse(saveString);
                
                // Restore globals
                currentStage = saveData.currentStage;
                // mapSeedVal is tricky. initMap uses mapSeedVal.
                // We rely on initMap's logic: mapSeedVal = 100 + currentStage * 997.
                // This reconstructs the base map.
                
                // 1. Rebuild terrain (preserveEntities = true prevents spawning new enemies/resetting player pos)
                initMap(true); 

                // 2. Overwrite entities with saved data
                player = saveData.player;
                enemies = saveData.enemies;
                lootedObjects = saveData.lootedObjects;

                // 3. Reset UI state
                currentState = STATE_WORLD;
                previousState = STATE_WORLD;
                document.getElementById('ui-panel').style.display = 'flex';
                pauseModal.classList.add('hidden');
                updateHUD();
                
                showToast("Game Loaded!");

            } catch (e) {
                console.error("Load failed", e);
                showToast("Save Data Corrupt!");
            }
        });

        bindButton(quitBtn, () => {
            pauseModal.classList.add('hidden');
            restartGame();
        });


        // --- Game Loop ---
        let lastTime = 0;
        let previousState = STATE_WORLD;

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            if (currentState !== STATE_GAME_OVER && currentState !== STATE_PAUSED) {
                update(deltaTime);
            }
            
            // Draw continuously even when paused
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            if (currentState === STATE_WORLD) updateWorld(dt);
            else if (currentState === STATE_BATTLE) updateBattle(dt);
            
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const txt = floatingTexts[i];
                txt.time -= dt;
                txt.y -= 20 * dt; 
                if (txt.time <= 0) floatingTexts.splice(i, 1);
            }

            if (shakeAmount > 0) {
                shakeAmount -= dt * 30;
                if (shakeAmount < 0) shakeAmount = 0;
            }
            if (battleCooldown > 0) {
                battleCooldown -= dt;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            if (shakeAmount > 0) {
                const dx = (Math.random() - 0.5) * shakeAmount;
                const dy = (Math.random() - 0.5) * shakeAmount;
                ctx.translate(dx, dy);
            }

            if (currentState === STATE_WORLD || (currentState === STATE_PAUSED && previousState === STATE_WORLD)) drawWorld();
            else if (currentState === STATE_BATTLE || (currentState === STATE_PAUSED && previousState === STATE_BATTLE)) drawBattle();

            ctx.restore();
            
            if (shakeAmount > 5) {
                ctx.fillStyle = `rgba(255, 0, 0, ${shakeAmount / 40})`;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            }
        }

        function getTitle(level) {
            const index = Math.floor((level - 1) / 5);
            return TITLES[Math.min(index, TITLES.length - 1)];
        }

        // --- World Update ---
        function updateBattleJoystick(dt) {
            joystickTimer -= dt;
            if (joystickTimer > 0) return;

            if (joystickVector.y < -0.5) {
                handleBattleInput('ArrowUp');
                joystickTimer = 0.3;
            } else if (joystickVector.y > 0.5) {
                handleBattleInput('ArrowDown');
                joystickTimer = 0.3;
            }
        }

        function handleWorldInput(key) {
            if (key === 'Enter' || key === ' ') {
                const cx = player.x + 15;
                const cy = player.y + 15;
                
                const dist = Math.sqrt((player.x - coffeeMachineLoc.x)**2 + (player.y - coffeeMachineLoc.y)**2);
                if (dist < 60) {
                    player.hp = player.maxHp;
                    player.status = null;
                    player.consultants.forEach(c => c.hp = c.maxHp);
                    
                    playSound('heal');
                    floatingTexts.push({
                        text: "Coffee Break! Team HP Maxed!",
                        x: player.x,
                        y: player.y - 30,
                        color: '#f1c40f',
                        time: 1.5
                    });
                    updateHUD();
                    return;
                }

                const c = Math.floor(cx / TILE_SIZE);
                const r = Math.floor(cy / TILE_SIZE);
                const neighbors = [
                    {r:r, c:c}, {r:r-1, c:c}, {r:r+1, c:c}, {r:r, c:c-1}, {r:r, c:c+1}
                ];

                let looted = false;
                neighbors.forEach(n => {
                    if (looted) return;
                    const obj = objectMap[n.r][n.c];
                    const id = `${n.r},${n.c}`;
                    if ((obj === OBJ_DESK || obj === OBJ_PLANT) && !lootedObjects.includes(id)) {
                        lootedObjects.push(id);
                        playSound('action');
                        if (Math.random() < 0.5) {
                            player.inventory.donuts++;
                            floatingTexts.push({ text: "Found Donut!", x: n.c*TILE_SIZE, y: n.r*TILE_SIZE, color: '#e67e22', time: 1.5 });
                        } else {
                            floatingTexts.push({ text: "Empty...", x: n.c*TILE_SIZE, y: n.r*TILE_SIZE, color: '#ccc', time: 1.0 });
                        }
                        looted = true;
                        updateHUD();
                    }
                });
            }
        }

        function updateWorld(dt) {
            let dx = joystickVector.x;
            let dy = joystickVector.y;

            if (keys['ArrowUp']) dy = -1;
            if (keys['ArrowDown']) dy = 1;
            if (keys['ArrowLeft']) dx = -1;
            if (keys['ArrowRight']) dx = 1;

            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 1) { dx /= len; dy /= len; }

            if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                const nextX = player.x + dx * player.speed * dt;
                const nextY = player.y + dy * player.speed * dt;

                const c = Math.floor((nextX + 15) / TILE_SIZE);
                const r = Math.floor((nextY + 15) / TILE_SIZE);
                
                if (objectMap[r] && objectMap[r][c] === OBJ_EXIT_DOOR) {
                    if (player.signatures >= SIGNATURES_NEEDED) {
                        nextStage();
                        return; 
                    } else {
                        floatingTexts.push({
                            text: `Locked! Need ${SIGNATURES_NEEDED} Signatures!`,
                            x: player.x,
                            y: player.y - 30,
                            color: '#e74c3c',
                            time: 0.1 
                        });
                        return; 
                    }
                }

                if (!checkCollision(nextX, player.y)) {
                    player.x = nextX;
                }
                if (!checkCollision(player.x, nextY)) {
                    player.y = nextY;
                }
                
                player.isWalking = true;
            } else {
                player.isWalking = false;
            }

            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);
                if (dist < 40 && battleCooldown <= 0) { 
                    startBattle(enemy, i);
                    break;
                }
            }
            updateHUD();
        }

        function nextStage() {
            currentStage++;
            playSound('victory');
            floatingTexts.push({
                text: "STAGE CLEAR!",
                x: SCREEN_WIDTH/2,
                y: SCREEN_HEIGHT/2,
                color: '#2ecc71',
                time: 3.0
            });
            initMap();
        }

        function checkCollision(x, y) {
            const points = [
                { x: x, y: y },
                { x: x + player.width, y: y },
                { x: x, y: y + player.height },
                { x: x + player.width, y: y + player.height }
            ];

            for (let p of points) {
                const c = Math.floor(p.x / TILE_SIZE);
                const r = Math.floor(p.y / TILE_SIZE);

                if (c < 0 || c >= MAP_COLS || r < 0 || r >= MAP_ROWS) return true;
                if (worldMap[r][c] === TILE_WALL) return true;
                if (objectMap[r][c] !== OBJ_NONE && objectMap[r][c] !== OBJ_EXIT_DOOR) return true;
            }
            return false;
        }

        function drawWorld() {
            for (let r = 0; r < MAP_ROWS; r++) {
                for (let c = 0; c < MAP_COLS; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    ctx.fillStyle = COLOR_FLOOR;
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    
                    ctx.fillStyle = 'rgba(0,0,0,0.03)';
                    if ((r+c)%2 === 0) ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                    ctx.strokeStyle = '#d0d0d0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

                    if (worldMap[r][c] === TILE_WALL) {
                        ctx.fillStyle = COLOR_WALL;
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#444';
                        ctx.fillRect(x, y + TILE_SIZE - 5, TILE_SIZE, 5);
                    }

                    const obj = objectMap[r][c];
                    if (obj !== OBJ_NONE) {
                        const id = `${r},${c}`;
                        drawObject(ctx, x, y, obj, lootedObjects.includes(id));
                    }
                }
            }

            enemies.forEach(e => {
                drawCharacter(ctx, e.x, e.y, e.type, 1, false, 0, e.status);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(e.x - 5, e.y - 12, e.width + 10, 10);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(e.name, e.x + e.width/2, e.y - 4);
            });

            drawCharacter(ctx, player.x, player.y, player.type, 1, false, 0, player.status, player.isWalking);
            
            floatingTexts.forEach(txt => {
                ctx.save();
                ctx.fillStyle = txt.color;
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(txt.text, txt.x, txt.y);
                ctx.restore();
            });

            if (battleCooldown > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText("SAFE!", player.x - 10, player.y - 10);
            }
        }

        // --- Battle System ---
        let currentEnemyIndex = -1;

        function startBattle(enemy, index) {
            currentState = STATE_BATTLE;
            currentEnemyIndex = index;
            document.getElementById('ui-panel').style.display = 'none';

            battleState = {
                enemy: enemy,
                menuSelection: 0,
                attackSelection: 0,
                consultantSelection: 0, 
                fighterIndex: -1, 
                phase: 'MENU',
                log: `You encountered a ${enemy.name}!`,
                turn: 'PLAYER',
                animTimer: 0, 
                onAck: null,
                itemSelection: 0
            };

            joystickVector = { x: 0, y: 0 };
            keys['ArrowUp'] = false; keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false; keys['ArrowRight'] = false;
        }

        function useItem(itemName) {
            const fighter = getActiveFighter();
            if (itemName === "Donut") {
                if (player.inventory.donuts > 0) {
                    player.inventory.donuts--;
                    fighter.hp = Math.min(fighter.maxHp, fighter.hp + 10);
                    fighter.status = null;
                    playSound('heal');
                    battleState.log = `Ate Donut! +10 Sanity.`;
                } else {
                    battleState.log = "No Donuts left!";
                    battleState.phase = 'MESSAGE';
                    battleState.onAck = () => { battleState.phase = 'ITEM_SELECT'; };
                    return; 
                }
            }
            battleState.phase = 'MESSAGE';
            battleState.onAck = () => enemyTurn();
        }

        function handleBattleInput(key) {
             playSound('action');

             if (battleState.phase === 'DEFEAT_ANIMATION') return; 

             if (battleState.phase === 'MESSAGE') {
                 if (key === 'Enter' || key === ' ') {
                     if (battleState.onAck) {
                         const callback = battleState.onAck;
                         battleState.onAck = null; 
                         callback();
                     }
                 }
                 return;
             }

             if (battleState.phase === 'MENU') {
                const fighter = getActiveFighter();
                if (fighter.status && fighter.status.type === 'STUN') {
                    if (key === 'Enter' || key === ' ') {
                        battleState.log = "You are Stunned! Turn skipped.";
                        fighter.status = null;
                        battleState.phase = 'MESSAGE';
                        battleState.onAck = () => enemyTurn();
                        return;
                    }
                }

                // MENU: 0=FIGHT, 1=ITEM, 2=HIRE, 3=SWITCH, 4=RUN
                if (key === 'ArrowUp') battleState.menuSelection = (battleState.menuSelection - 1 + 5) % 5; 
                if (key === 'ArrowDown') battleState.menuSelection = (battleState.menuSelection + 1) % 5;
                if (key === 'Enter' || key === ' ') {
                    if (battleState.menuSelection === 0) { // FIGHT
                        battleState.phase = 'ATTACK_SELECT';
                        battleState.attackSelection = 0;
                        battleState.log = "Select Action:";
                    } else if (battleState.menuSelection === 1) { // ITEM
                        battleState.phase = 'ITEM_SELECT';
                        battleState.itemSelection = 0;
                        battleState.log = "Select Item:";
                    } else if (battleState.menuSelection === 2) { // HIRE
                        attemptCatch();
                    } else if (battleState.menuSelection === 3) { // SWITCH
                        if (player.consultants.length > 0) {
                            battleState.phase = 'SWITCH_SELECT';
                            battleState.consultantSelection = 0;
                            battleState.log = "Select Consultant:";
                        } else {
                            battleState.log = "No consultants hired!";
                            battleState.phase = 'MESSAGE';
                            battleState.onAck = () => { battleState.phase = 'MENU'; battleState.log = "Action?"; };
                        }
                    } else if (battleState.menuSelection === 4) { // RUN
                        if (Math.random() < 0.5) {
                            battleState.log = "Ran away safely!";
                            const enemy = battleState.enemy;
                            let dx = player.x - enemy.x;
                            let dy = player.y - enemy.y;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) {
                                const stepDist = 60;
                                const moveX = (dx / dist) * stepDist;
                                const moveY = (dy / dist) * stepDist;
                                const newX = player.x + moveX;
                                const newY = player.y + moveY;
                                if (!checkCollision(newX, newY)) {
                                    player.x = newX;
                                    player.y = newY;
                                }
                            }
                            battleCooldown = 2.0;
                            battleState.phase = 'MESSAGE';
                            battleState.onAck = () => { 
                                currentState = STATE_WORLD; 
                                document.getElementById('ui-panel').style.display = 'flex';
                                updateHUD(); 
                            };
                        } else {
                            battleState.log = "Failed to run!";
                            battleState.phase = 'MESSAGE';
                            battleState.onAck = () => enemyTurn();
                        }
                    }
                }
            } else if (battleState.phase === 'ATTACK_SELECT') {
                if (key === 'ArrowUp') battleState.attackSelection = (battleState.attackSelection - 1 + 4) % 4;
                if (key === 'ArrowDown') battleState.attackSelection = (battleState.attackSelection + 1) % 4;
                if (key === 'Escape') {
                    battleState.phase = 'MENU';
                    battleState.log = "What will you do?";
                }
                let moves = PLAYER_ATTACKS;
                if (battleState.fighterIndex !== -1) {
                    moves = ENEMY_MOVES["Consultant"]; 
                }
                if (key === 'Enter' || key === ' ') performAttack(moves[battleState.attackSelection]);
            } else if (battleState.phase === 'ITEM_SELECT') {
                // Just one item for now
                if (key === 'Escape') {
                    battleState.phase = 'MENU';
                    battleState.log = "Action?";
                }
                if (key === 'Enter' || key === ' ') {
                    useItem("Donut");
                }
            } else if (battleState.phase === 'SWITCH_SELECT') {
                const count = player.consultants.length + 1; 
                if (key === 'ArrowUp') battleState.consultantSelection = (battleState.consultantSelection - 1 + count) % count;
                if (key === 'ArrowDown') battleState.consultantSelection = (battleState.consultantSelection + 1) % count;
                if (key === 'Escape') {
                    battleState.phase = 'MENU';
                    battleState.log = "Action?";
                }
                if (key === 'Enter' || key === ' ') {
                    let targetIndex = battleState.consultantSelection - 1; 
                    let targetFighter = (targetIndex === -1) ? player : player.consultants[targetIndex];
                    
                    if (targetFighter.hp <= 0) {
                        battleState.log = `${targetFighter.name} is exhausted!`;
                        battleState.phase = 'MESSAGE';
                        battleState.onAck = () => { battleState.phase = 'SWITCH_SELECT'; };
                    } else if (targetIndex === battleState.fighterIndex) {
                         battleState.log = "Already selected!";
                         battleState.phase = 'MESSAGE';
                         battleState.onAck = () => { battleState.phase = 'SWITCH_SELECT'; };
                    } else {
                        battleState.fighterIndex = targetIndex;
                        battleState.log = `Go, ${targetFighter.name}!`;
                        battleState.phase = 'MESSAGE';
                        battleState.onAck = () => enemyTurn();
                    }
                }
            } else if (battleState.phase === 'END' || battleState.phase === 'LEVEL_UP') {
                 if (key === 'Enter' || key === ' ') {
                     if (battleState.enemy.hp <= 0 || battleState.phase === 'LEVEL_UP') {
                         if (currentEnemyIndex > -1) {
                             enemies.splice(currentEnemyIndex, 1);
                         }
                     }
                     currentState = STATE_WORLD;
                     document.getElementById('ui-panel').style.display = 'flex';
                     updateHUD();
                 }
            }
        }

        function performAttack(attack) {
            const fighter = getActiveFighter();

            if (player.status && player.status.type === 'NAUSEA') {
                player.hp -= 2;
                if (player.hp <= 0) { player.hp = 0; currentState = STATE_GAME_OVER; return; }
            }

            // Note: isItem check removed from here as items are handled via useItem

            playSound('attack');

            let multiplier = getTypeEffectiveness(player.dept, battleState.enemy.dept);
            let damage = Math.floor(attack.damage * multiplier + player.level / 2);
            if (player.consultants > 0) damage += player.consultants.length; // Small bonus

            if (attack.effect && Math.random() < attack.chance) {
                battleState.enemy.status = { type: attack.effect };
                battleState.log = `Used ${attack.name}! Enemy ${attack.effect}!`;
            } else {
                let effText = multiplier > 1 ? "Super Effective!" : (multiplier < 1 ? "Not Effective..." : "");
                battleState.log = `Used ${attack.name}! ${damage} dmg. ${effText}`;
            }
            
            battleState.enemy.hp -= damage;
            
            battleState.phase = 'MESSAGE';
            battleState.onAck = () => {
                if (battleState.enemy.hp <= 0) {
                    battleState.enemy.hp = 0;
                    playSound('defeat');
                    battleState.phase = 'DEFEAT_ANIMATION';
                    battleState.animTimer = 0;
                } else {
                    enemyTurn();
                }
            };
        }

        function attemptCatch() {
            if (player.consultants.length >= 3) {
                battleState.log = "Team full (Max 3)!";
                battleState.phase = 'MESSAGE';
                battleState.onAck = () => { battleState.phase = 'MENU'; battleState.log = "Action?"; };
                return;
            }

            if (battleState.enemy.type === "Consultant") {
                if (Math.random() < 0.6) {
                    const newCon = {
                        name: "Consultant",
                        type: "Consultant",
                        dept: FACT_POLITICIAN, 
                        level: battleState.enemy.level || 1,
                        hp: battleState.enemy.hp, 
                        maxHp: battleState.enemy.maxHp,
                        xp: 0,
                        nextLevelXp: 50,
                        status: null
                    };
                    player.consultants.push(newCon);
                    playSound('victory');
                    battleState.log = "Hired Consultant!";
                    battleState.phase = 'MESSAGE';
                    battleState.onAck = () => { 
                        currentState = STATE_WORLD; 
                        enemies.splice(currentEnemyIndex, 1); 
                        document.getElementById('ui-panel').style.display = 'flex';
                        updateHUD(); 
                    };
                } else {
                    battleState.log = "Offer refused!";
                    battleState.phase = 'MESSAGE';
                    battleState.onAck = () => enemyTurn();
                }
            } else {
                battleState.log = "Can only hire Consultants!";
                battleState.phase = 'MESSAGE';
                battleState.onAck = () => { battleState.phase = 'MENU'; battleState.log = "Action?"; };
            }
        }

        function enemyTurn() {
            if (currentState !== STATE_BATTLE) return;
            const fighter = getActiveFighter();

            if (battleState.enemy.status) {
                if (battleState.enemy.status.type === 'STUN') {
                    battleState.log = "Enemy is Stunned!";
                    battleState.enemy.status = null;
                    battleState.phase = 'MESSAGE';
                    battleState.onAck = () => { battleState.phase = 'MENU'; battleState.log = "Action?"; };
                    return;
                }
                if (battleState.enemy.status.type === 'CONFUSE') {
                    if (Math.random() < 0.5) {
                        battleState.log = "Enemy Confused! Hurts itself!";
                        playSound('hit');
                        battleState.enemy.hp -= 3;
                        battleState.phase = 'MESSAGE';
                        battleState.onAck = () => {
                            if (battleState.enemy.hp <= 0) {
                                 playSound('defeat');
                                 battleState.phase = 'DEFEAT_ANIMATION';
                                 battleState.animTimer = 0;
                            }
                            else { battleState.phase = 'MENU'; battleState.log = "Action?"; }
                        };
                        return;
                    }
                }
            }

            const moves = ENEMY_MOVES[battleState.enemy.type] || ENEMY_MOVES["Consultant"];
            const move = moves[Math.floor(Math.random() * moves.length)];
            
            const levelScale = 1 + (player.level * 0.1);
            let multiplier = getTypeEffectiveness(move.type || FACT_NEUTRAL, fighter.dept || FACT_OFFICER);
            let damage = Math.floor(move.damage * levelScale * multiplier);
            damage = Math.floor(damage * (0.8 + Math.random() * 0.4));
            if (damage < 1) damage = 1;

            if (move.effect && Math.random() < move.chance) {
                fighter.status = { type: move.effect };
                battleState.log = `${battleState.enemy.name} used ${move.name}! ${fighter.name} ${move.effect}!`;
            } else {
                let effText = multiplier > 1 ? " (Ouch!)" : (multiplier < 1 ? " (Resisted)" : "");
                battleState.log = `${battleState.enemy.name} used ${move.name}! -${damage} Sanity${effText}`;
            }

            playSound('hit');
            fighter.hp -= damage;
            shakeAmount = 20;

            battleState.phase = 'MESSAGE';
            battleState.onAck = () => {
                if (fighter.hp <= 0) {
                    fighter.hp = 0;
                    if (fighter === player) {
                        playSound('defeat');
                        currentState = STATE_GAME_OVER;
                        document.getElementById('final-score').innerText = `Score: ${player.score}`;
                        document.getElementById('game-over-modal').classList.remove('hidden');
                    } else {
                        battleState.log = `${fighter.name} retreated!`;
                        battleState.fighterIndex = -1; 
                        battleState.phase = 'MESSAGE';
                        battleState.onAck = () => { battleState.phase = 'MENU'; };
                    }
                } else {
                    battleState.phase = 'MENU';
                    battleState.log = "Action?";
                }
            };
        }

        function winBattle() {
            const fighter = getActiveFighter();
            const xpGain = battleState.enemy.xp;
            fighter.xp += xpGain;
            const scoreGain = battleState.enemy.maxHp * 10;
            player.score += scoreGain;
            
            let sigText = "";
            if (Math.random() < 0.5) {
                player.signatures++;
                sigText = " Found Signature!";
            }

            playSound('victory');
            battleState.log = `Win! +${xpGain} XP for ${fighter.name}. +${scoreGain} Pts.${sigText}`;
            battleState.phase = 'MESSAGE';
            battleState.onAck = () => {
                if (fighter.xp >= fighter.nextLevelXp) levelUp();
                else {
                    if (currentEnemyIndex > -1) enemies.splice(currentEnemyIndex, 1);
                    currentState = STATE_WORLD;
                    document.getElementById('ui-panel').style.display = 'flex';
                    updateHUD();
                }
            };
        }

        function levelUp() {
            const fighter = getActiveFighter();
            fighter.level++;
            fighter.xp -= fighter.nextLevelXp;
            fighter.nextLevelXp = Math.floor(fighter.nextLevelXp * 1.5);
            fighter.maxHp += 5;
            fighter.hp = fighter.maxHp;
            playSound('victory'); 
            battleState.log = `${fighter.name} leveled up to ${fighter.level}!`;
            battleState.phase = 'MESSAGE';
            battleState.onAck = () => {
                if (currentEnemyIndex > -1) enemies.splice(currentEnemyIndex, 1);
                currentState = STATE_WORLD;
                document.getElementById('ui-panel').style.display = 'flex';
                updateHUD();
            };
        }

        function restartGame() {
            player.level = 1;
            player.hp = 20;
            player.maxHp = 20;
            player.xp = 0;
            player.nextLevelXp = 50;
            player.score = 0;
            player.consultants = [];
            player.status = null;
            player.inventory.donuts = 1;
            currentStage = 1;

            document.getElementById('game-over-modal').classList.add('hidden');
            initMap();
            currentState = STATE_WORLD;
            previousState = STATE_WORLD;
            document.getElementById('ui-panel').style.display = 'flex';
            updateHUD();
            draw();
        }

        // --- Battle Update (with Animation) ---
        function updateBattle(dt) {
            updateBattleJoystick(dt);

            if (battleState.phase === 'DEFEAT_ANIMATION') {
                battleState.animTimer += dt;
                const t = battleState.animTimer;

                // Phase 1: Shake (0 to 0.5s)
                if (t < 0.5) {
                    battleState.enemy.shakeX = (Math.random() - 0.5) * 10;
                } 
                // Phase 2: Fall (0.5s to 1.0s)
                else if (t < 1.0) {
                    battleState.enemy.shakeX = 0;
                    const fallProgress = (t - 0.5) / 0.5; // 0 to 1
                    // Rotate 90 degrees (PI/2)
                    battleState.enemy.rotation = fallProgress * (Math.PI / 2);
                    // Move down slightly
                    battleState.enemy.yOffset = fallProgress * 40;
                } 
                // Phase 3: Done
                else {
                    battleState.enemy.rotation = Math.PI / 2;
                    battleState.enemy.yOffset = 40;
                    battleState.enemy.shakeX = 0;
                    
                    // Trigger win
                    battleState.phase = 'MESSAGE'; 
                    winBattle();
                }
            }
        }

        function drawBattle() {
            const grad = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT);
            grad.addColorStop(0, '#2c3e50');
            grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.ellipse(SCREEN_WIDTH/2, 350, 350, 100, 0, 0, Math.PI*2);
            ctx.fill();

            const enemy = battleState.enemy;
            drawCharacter(ctx, 500, 100, enemy.type, 4, false, 0, enemy.status, false, enemy.rotation, enemy.shakeX, enemy.yOffset);

            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`${enemy.name} (Lvl ${player.level})`, 450, 80);
            ctx.font = '16px Courier New';
            ctx.fillStyle = '#aaa';
            ctx.fillText(`Faction: ${enemy.dept}`, 450, 100); 
            
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.roundRect(450, 110, 200, 15, 5);
            ctx.fill();
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.roundRect(450, 110, 200 * (enemy.hp / enemy.maxHp), 15, 5);
            ctx.fill();

            const fighter = getActiveFighter();

            drawCharacter(ctx, 150, 200, fighter.type, 4, true, 0, fighter.status);

            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Courier New';
            ctx.fillText(`${fighter.name}`, 100, 230);
            ctx.font = '16px Courier New';
            ctx.fillStyle = '#aaa';
            ctx.fillText(`Faction: ${fighter.dept || FACT_OFFICER}`, 100, 250); 
            
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.roundRect(100, 260, 200, 15, 5);
            ctx.fill();
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.roundRect(100, 260, 200 * (fighter.hp / fighter.maxHp), 15, 5);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = '16px Courier New';
            ctx.fillText(`${fighter.hp} / ${fighter.maxHp} HP`, 100, 295);

            ctx.fillStyle = COLOR_MENU_BG;
            ctx.fillRect(0, 400, SCREEN_WIDTH, 200);
            ctx.strokeStyle = COLOR_MENU_BORDER;
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 405, SCREEN_WIDTH - 10, 190);

            ctx.fillStyle = 'white';
            ctx.font = '24px Courier New';
            ctx.fillText(battleState.log, 30, 450);

            const startX = 500;
            const startY = 480;

            if (battleState.phase === 'MESSAGE') {
                 ctx.fillStyle = '#f1c40f'; // Gold indicator
                 ctx.font = 'bold 20px Courier New';
                 ctx.fillText("[Press A to continue]", 500, 560);
            } else if (battleState.phase === 'MENU') {
                const options = ["FIGHT", "ITEM", "HIRE", "SWITCH", "RUN"];
                options.forEach((opt, index) => {
                    if (index === battleState.menuSelection) {
                        ctx.fillStyle = '#f1c40f';
                        ctx.fillText(`> ${opt}`, startX, startY + index * 40);
                    } else {
                        ctx.fillStyle = 'white';
                        ctx.fillText(`  ${opt}`, startX, startY + index * 40);
                    }
                });
            } else if (battleState.phase === 'ATTACK_SELECT') {
                let moves = PLAYER_ATTACKS;
                if (battleState.fighterIndex !== -1) {
                    moves = ENEMY_MOVES["Consultant"]; 
                }

                moves.forEach((att, index) => {
                    if (index === battleState.attackSelection) {
                         ctx.fillStyle = '#f1c40f';
                        ctx.fillText(`> ${att.name}`, startX, startY + index * 30 - 20);
                    } else {
                         ctx.fillStyle = 'white';
                        ctx.fillText(`  ${att.name}`, startX, startY + index * 30 - 20);
                    }
                });
            } else if (battleState.phase === 'ITEM_SELECT') {
                // Item list
                let label = `Eat Donut (${player.inventory.donuts})`;
                if (battleState.itemSelection === 0) {
                    ctx.fillStyle = '#f1c40f';
                    ctx.fillText(`> ${label}`, startX, startY);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.fillText(`  ${label}`, startX, startY);
                }
            } else if (battleState.phase === 'SWITCH_SELECT') {
                const roster = [player, ...player.consultants];
                roster.forEach((char, index) => {
                    let label = char.name;
                    if (char === player) label = "Player (You)"; 
                    label += ` HP:${char.hp}`;
                    
                    if (index === battleState.consultantSelection) {
                         ctx.fillStyle = '#f1c40f';
                        ctx.fillText(`> ${label}`, startX, startY + index * 30 - 20);
                    } else {
                         ctx.fillStyle = 'white';
                        ctx.fillText(`  ${label}`, startX, startY + index * 30 - 20);
                    }
                });
            }
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

