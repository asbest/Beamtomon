<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beamtomon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            border: 4px solid #fff;
            background-color: #000;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const TILE_SIZE = 40;
        const SCREEN_WIDTH = 800;
        const SCREEN_HEIGHT = 600;
        const MAP_COLS = SCREEN_WIDTH / TILE_SIZE;
        const MAP_ROWS = SCREEN_HEIGHT / TILE_SIZE;

        // Tile Types
        const TILE_FLOOR = 0;
        const TILE_WALL = 1;
        const TILE_DOOR = 2;

        // Colors
        const COLOR_FLOOR = '#cccccc';
        const COLOR_WALL = '#444444';
        const COLOR_PLAYER = '#0000ff';
        const COLOR_DOOR = '#8B4513';
        const COLOR_MENU_BG = '#303030';
        const COLOR_MENU_BORDER = '#ffffff';

        // Game State
        const STATE_WORLD = 'WORLD';
        const STATE_BATTLE = 'BATTLE';
        let currentState = STATE_WORLD;

        // Input
        const keys = {};

        // Input handling
        window.addEventListener('keydown', (e) => {
            if (keys[e.key]) return; // Prevent key repeat handling if not needed
            keys[e.key] = true;
            if (currentState === STATE_BATTLE) {
                handleBattleInput(e.key);
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Map Generation (Simple Office Layout)
        const worldMap = [];
        for (let r = 0; r < MAP_ROWS; r++) {
            const row = [];
            for (let c = 0; c < MAP_COLS; c++) {
                if (r === 0 || r === MAP_ROWS - 1 || c === 0 || c === MAP_COLS - 1) {
                    row.push(TILE_WALL);
                } else if (r % 5 === 0 && c > 2 && c < MAP_COLS - 3) {
                     // Internal walls for cubicles
                     if (c % 4 !== 0) row.push(TILE_WALL);
                     else row.push(TILE_FLOOR);
                } else {
                    row.push(TILE_FLOOR);
                }
            }
            worldMap.push(row);
        }

        // Data
        const TITLES = [
            "AnwÃ¤rter",         // Level 1-4
            "Inspektor",        // Level 5-9
            "Oberinspektor",    // Level 10-14
            "Amtmann",          // Level 15-19
            "Amtsrat",          // Level 20+
        ];

        const ATTACKS = [
            { name: "Permission Denied", damage: 4 },
            { name: "Pass the Buck", damage: 6 },
            { name: "Coffee Break", damage: 2 }, // Maybe heal? For now dmg
            { name: "Form A38", damage: 8 }
        ];

        const ENEMY_TYPES = [
            { name: "Consultant", color: "#FFA500", hp: 15, xp: 20 },
            { name: "Politician", color: "#800080", hp: 25, xp: 30 },
            { name: "Citizen", color: "#008000", hp: 10, xp: 10 },
            { name: "Other Beamter", color: "#808080", hp: 20, xp: 25 }
        ];

        // Player Object
        const player = {
            x: 2,
            y: 2,
            color: COLOR_PLAYER,
            moveTimer: 0,
            moveInterval: 200, // ms between moves
            lastMoveTime: 0,
            level: 1,
            hp: 20,
            maxHp: 20,
            xp: 0,
            nextLevelXp: 50,
            consultants: 0 // Count of caught consultants
        };

        function getTitle(level) {
            const index = Math.floor((level - 1) / 5);
            return TITLES[Math.min(index, TITLES.length - 1)];
        }

        // Battle State
        let battleState = {
            enemy: null,
            menuSelection: 0, // 0: Fight, 1: Catch, 2: Run
            attackSelection: 0,
            phase: 'MENU', // MENU, ATTACK_SELECT, BATTLE_ANIMATION, END, LEVEL_UP
            log: "",
            turn: 'PLAYER'
        };

        // Game Loop
        let lastTime = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime, timestamp);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime, timestamp) {
            if (currentState === STATE_WORLD) {
                updateWorld(deltaTime, timestamp);
            } else if (currentState === STATE_BATTLE) {
                // Battle is event driven
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentState === STATE_WORLD) {
                drawWorld();
            } else if (currentState === STATE_BATTLE) {
                drawBattle();
            }
        }

        function isWalkable(x, y) {
            if (x < 0 || x >= MAP_COLS || y < 0 || y >= MAP_ROWS) return false;
            return worldMap[y][x] !== TILE_WALL;
        }

        function updateWorld(deltaTime, timestamp) {
             // Simple grid movement
             if (timestamp - player.lastMoveTime > player.moveInterval) {
                let dx = 0;
                let dy = 0;

                if (keys['ArrowUp']) dy = -1;
                else if (keys['ArrowDown']) dy = 1;
                else if (keys['ArrowLeft']) dx = -1;
                else if (keys['ArrowRight']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    const newX = player.x + dx;
                    const newY = player.y + dy;

                    if (isWalkable(newX, newY)) {
                        player.x = newX;
                        player.y = newY;
                        player.lastMoveTime = timestamp;

                        // Check for random encounter (10% chance per step)
                        if (Math.random() < 0.1) {
                            // Reset keys to prevent holding key causing immediate action in battle
                            startBattle();
                        }
                    }
                }
             }
        }

        function drawWorld() {
            // Draw Map
            for (let r = 0; r < MAP_ROWS; r++) {
                for (let c = 0; c < MAP_COLS; c++) {
                    const tile = worldMap[r][c];
                    let color = COLOR_FLOOR;
                    if (tile === TILE_WALL) color = COLOR_WALL;
                    else if (tile === TILE_DOOR) color = COLOR_DOOR;

                    ctx.fillStyle = color;
                    ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    // Grid lines (optional, for office look)
                    ctx.strokeStyle = '#bbb';
                    ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw Player
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x * TILE_SIZE + 5, player.y * TILE_SIZE + 5, TILE_SIZE - 10, TILE_SIZE - 10);

            // UI Overlay
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 250, 60);
            ctx.fillStyle = 'white';
            ctx.font = '16px Courier New';
            ctx.fillText(`${getTitle(player.level)} (Lvl ${player.level})`, 10, 20);
            ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, 10, 40);
        }

        // --- Battle System ---

        function startBattle() {
            currentState = STATE_BATTLE;
            // Generate Random Enemy
            // Scale enemy HP with player level
            const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
            const levelScale = 1 + (player.level - 1) * 0.2;

            battleState = {
                enemy: {
                    ...type,
                    maxHp: Math.floor(type.hp * levelScale),
                    hp: Math.floor(type.hp * levelScale),
                    xp: Math.floor(type.xp * levelScale)
                },
                menuSelection: 0,
                attackSelection: 0,
                phase: 'MENU',
                log: `A wild ${type.name} appears!`,
                turn: 'PLAYER'
            };

            // Clear keys
             Object.keys(keys).forEach(k => keys[k] = false);
        }

        function handleBattleInput(key) {
            if (battleState.phase === 'MENU') {
                if (key === 'ArrowUp') battleState.menuSelection = (battleState.menuSelection - 1 + 3) % 3;
                if (key === 'ArrowDown') battleState.menuSelection = (battleState.menuSelection + 1) % 3;
                if (key === 'Enter' || key === ' ') {
                    if (battleState.menuSelection === 0) {
                        battleState.phase = 'ATTACK_SELECT';
                        battleState.attackSelection = 0;
                        battleState.log = "Select Attack:";
                    } else if (battleState.menuSelection === 1) {
                         // Catch
                         attemptCatch();
                    } else if (battleState.menuSelection === 2) {
                         // Run
                         battleState.log = "You filed a transfer request (Ran away)...";
                         battleState.phase = 'END';
                    }
                }
            } else if (battleState.phase === 'ATTACK_SELECT') {
                if (key === 'ArrowUp') battleState.attackSelection = (battleState.attackSelection - 1 + 4) % 4;
                if (key === 'ArrowDown') battleState.attackSelection = (battleState.attackSelection + 1) % 4;
                if (key === 'Backspace' || key === 'Escape') {
                    battleState.phase = 'MENU';
                    battleState.log = "What will you do?";
                }
                if (key === 'Enter' || key === ' ') {
                    performAttack(ATTACKS[battleState.attackSelection]);
                }
            }
            else if (battleState.phase === 'END') {
                 if (key === 'Enter' || key === ' ') {
                     currentState = STATE_WORLD;
                 }
            }
            else if (battleState.phase === 'LEVEL_UP') {
                 if (key === 'Enter' || key === ' ') {
                     currentState = STATE_WORLD;
                 }
            }
        }

        function performAttack(attack) {
            // Player Attack
            // Consultant bonus damage?
            let damage = attack.damage + Math.floor(player.level / 2);
            if (player.consultants > 0) damage += player.consultants; // Consultants help fight

            battleState.enemy.hp -= damage;
            battleState.log = `Used ${attack.name}! Dealt ${damage} dmg.`;
            battleState.phase = 'BATTLE_ANIMATION'; // Lock input

            if (battleState.enemy.hp <= 0) {
                battleState.enemy.hp = 0;
                setTimeout(() => {
                    winBattle();
                }, 1000);
            } else {
                setTimeout(enemyTurn, 1000);
            }
        }

        function attemptCatch() {
            if (battleState.enemy.name === "Consultant") {
                const catchChance = 0.5 + (1 - battleState.enemy.hp / battleState.enemy.maxHp) * 0.5;
                if (Math.random() < catchChance) {
                    player.consultants++;
                    battleState.log = "You hired the Consultant!";
                    battleState.phase = 'END';
                } else {
                    battleState.log = "The Consultant refused your offer!";
                    battleState.phase = 'BATTLE_ANIMATION';
                    setTimeout(enemyTurn, 1000);
                }
            } else {
                battleState.log = "You can only hire Consultants!";
                battleState.phase = 'BATTLE_ANIMATION';
                setTimeout(() => {
                    battleState.phase = 'MENU';
                    battleState.log = "What will you do?";
                }, 1000);
            }
        }

        function enemyTurn() {
            if (currentState !== STATE_BATTLE) return;

            // Enemy Attack
            const damage = Math.max(1, Math.floor(player.level * 1.5) - 2 + Math.floor(Math.random() * 3));

            player.hp -= damage;
            battleState.log = `${battleState.enemy.name} attacked! Took ${damage} dmg.`;

            if (player.hp <= 0) {
                player.hp = 0;
                battleState.phase = 'END';
                battleState.log = "Burnout! You fainted. (Press Space)";
                // Reset player?
                player.hp = player.maxHp;
                player.x = 2;
                player.y = 2;
            } else {
                battleState.phase = 'MENU';
                // Wait a bit to read log
            }
        }

        function winBattle() {
            const xpGain = battleState.enemy.xp;
            player.xp += xpGain;
            battleState.log = `Enemy defeated! Gained ${xpGain} XP.`;

            if (player.xp >= player.nextLevelXp) {
                setTimeout(() => {
                    levelUp();
                }, 1000);
            } else {
                battleState.phase = 'END';
            }
        }

        function levelUp() {
            player.level++;
            player.xp -= player.nextLevelXp;
            player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5);
            player.maxHp += 5;
            player.hp = player.maxHp;

            const newTitle = getTitle(player.level);
            battleState.log = `Promoted to ${newTitle}! (Lvl ${player.level})`;
            battleState.phase = 'LEVEL_UP';
        }

        function drawBattle() {
            // Background
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            // Battle Arena Area
            ctx.fillStyle = '#eee';
            ctx.fillRect(50, 50, 700, 350);

            // Enemy
            const enemy = battleState.enemy;
            ctx.fillStyle = enemy.color;
            ctx.fillRect(500, 100, 100, 100);

            // Enemy Stats
            ctx.fillStyle = 'black';
            ctx.font = '20px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`${enemy.name}`, 450, 80);
            ctx.fillStyle = 'red';
            ctx.fillRect(450, 90, 200, 10);
            ctx.fillStyle = 'green';
            ctx.fillRect(450, 90, 200 * (enemy.hp / enemy.maxHp), 10);

            // Player (Back view representation)
            ctx.fillStyle = player.color;
            ctx.fillRect(150, 250, 100, 100);

            // Player Stats
            ctx.fillStyle = 'black';
            ctx.fillText(`${getTitle(player.level)}`, 150, 230);
             ctx.fillStyle = 'red';
            ctx.fillRect(150, 240, 200, 10);
            ctx.fillStyle = 'green';
            ctx.fillRect(150, 240, 200 * (player.hp / player.maxHp), 10);
            ctx.fillStyle = 'black';
            ctx.fillText(`${player.hp}/${player.maxHp}`, 360, 250);

            // Menu / Dialog Box
            ctx.fillStyle = COLOR_MENU_BG;
            ctx.fillRect(0, 400, SCREEN_WIDTH, 200);
            ctx.strokeStyle = COLOR_MENU_BORDER;
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 405, SCREEN_WIDTH - 10, 190);

            // Text
            ctx.fillStyle = 'white';
            ctx.font = '24px Courier New';
            ctx.fillText(battleState.log, 30, 450);

            // Menu Options
            const startX = 500;
            const startY = 480;

            if (battleState.phase === 'MENU') {
                const options = ["FIGHT", "HIRE (Catch)", "TRANSFER (Run)"];
                options.forEach((opt, index) => {
                    if (index === battleState.menuSelection) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillText(`> ${opt}`, startX, startY + index * 40);
                    } else {
                        ctx.fillStyle = 'white';
                        ctx.fillText(`  ${opt}`, startX, startY + index * 40);
                    }
                });
            } else if (battleState.phase === 'ATTACK_SELECT') {
                ATTACKS.forEach((att, index) => {
                    if (index === battleState.attackSelection) {
                         ctx.fillStyle = '#ffff00';
                        ctx.fillText(`> ${att.name}`, startX, startY + index * 30 - 20);
                    } else {
                         ctx.fillStyle = 'white';
                        ctx.fillText(`  ${att.name}`, startX, startY + index * 30 - 20);
                    }
                });
            } else if (battleState.phase === 'END' || battleState.phase === 'LEVEL_UP') {
                 ctx.fillStyle = '#ffff00';
                 ctx.fillText("Press Space to continue...", startX, startY + 40);
            }
        }

        // Start Game
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
